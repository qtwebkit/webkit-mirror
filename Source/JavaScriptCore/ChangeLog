2018-02-08  Don Olmstead  <don.olmstead@sony.com>

        Remove JavaScriptCore/ForwardingHeaders directory
        https://bugs.webkit.org/show_bug.cgi?id=182594

        Reviewed by Mark Lam.

        * CMakeLists.txt:
        * ForwardingHeaders/JavaScriptCore/APICast.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSBase.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSCTestRunnerUtils.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSContextRef.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSObjectRef.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSObjectRefPrivate.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSRetainPtr.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSStringRef.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSStringRefCF.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSTypedArray.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JSValueRef.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JavaScript.h: Removed.
        * ForwardingHeaders/JavaScriptCore/JavaScriptCore.h: Removed.
        * ForwardingHeaders/JavaScriptCore/OpaqueJSString.h: Removed.
        * ForwardingHeaders/JavaScriptCore/WebKitAvailability.h: Removed.

2018-02-06  Brian Burg  <bburg@apple.com>

        Web Inspector: protocol generator should automatically deduce the correct include style to use
        https://bugs.webkit.org/show_bug.cgi?id=182505

        Reviewed by Timothy Hatcher.

        Currently the generated imports use a mix of system header imports (powered by forwarding headers)
        and framework-style includes. Since forwarding headers are going away, this patch stops
        using system header includes for headers that are JavaScriptCore private headers. Instead,
        use either a relative include or a framework include.

        * inspector/scripts/codegen/generate_cpp_alternate_backend_dispatcher_header.py:
        (CppAlternateBackendDispatcherHeaderGenerator.generate_output):
        (CppAlternateBackendDispatcherHeaderGenerator):
        (CppAlternateBackendDispatcherHeaderGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_backend_dispatcher_header.py:
        (CppBackendDispatcherHeaderGenerator.generate_output):
        (CppBackendDispatcherHeaderGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_backend_dispatcher_implementation.py:
        (CppBackendDispatcherImplementationGenerator.generate_output):
        (CppBackendDispatcherImplementationGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_frontend_dispatcher_header.py:
        (CppFrontendDispatcherHeaderGenerator.generate_output):
        (CppFrontendDispatcherHeaderGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_frontend_dispatcher_implementation.py:
        (CppFrontendDispatcherImplementationGenerator.generate_output):
        (CppFrontendDispatcherImplementationGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_protocol_types_header.py:
        (CppProtocolTypesHeaderGenerator.generate_output):
        (CppProtocolTypesHeaderGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_cpp_protocol_types_implementation.py:
        (CppProtocolTypesImplementationGenerator.generate_output):
        (CppProtocolTypesImplementationGenerator._generate_secondary_header_includes):
        * inspector/scripts/codegen/generate_objc_backend_dispatcher_header.py:
        (ObjCBackendDispatcherHeaderGenerator):
        Convert existing header lists to the new entries format, which includes the
        allowable target frameworks and the relative path to the header.

        * inspector/scripts/codegen/generator.py:
        (Generator.generate_includes_from_entries):
        Copied from the same in the builtins code generator. It still works great.

        * inspector/scripts/tests/all/expected/definitions-with-mac-platform.json-result:
        * inspector/scripts/tests/generic/expected/commands-with-async-attribute.json-result:
        * inspector/scripts/tests/generic/expected/commands-with-optional-call-return-parameters.json-result:
        * inspector/scripts/tests/generic/expected/definitions-with-mac-platform.json-result:
        * inspector/scripts/tests/generic/expected/domain-availability.json-result:
        * inspector/scripts/tests/generic/expected/domains-with-varying-command-sizes.json-result:
        * inspector/scripts/tests/generic/expected/enum-values.json-result:
        * inspector/scripts/tests/generic/expected/events-with-optional-parameters.json-result:
        * inspector/scripts/tests/generic/expected/generate-domains-with-feature-guards.json-result:
        * inspector/scripts/tests/generic/expected/same-type-id-different-domain.json-result:
        * inspector/scripts/tests/generic/expected/shadowed-optional-type-setters.json-result:
        * inspector/scripts/tests/generic/expected/type-declaration-aliased-primitive-type.json-result:
        * inspector/scripts/tests/generic/expected/type-declaration-array-type.json-result:
        * inspector/scripts/tests/generic/expected/type-declaration-enum-type.json-result:
        * inspector/scripts/tests/generic/expected/type-declaration-object-type.json-result:
        * inspector/scripts/tests/generic/expected/type-requiring-runtime-casts.json-result:
        * inspector/scripts/tests/generic/expected/type-with-open-parameters.json-result:
        * inspector/scripts/tests/generic/expected/worker-supported-domains.json-result:
        * inspector/scripts/tests/ios/expected/definitions-with-mac-platform.json-result:
        * inspector/scripts/tests/mac/expected/definitions-with-mac-platform.json-result:
        Rebaseline.

2018-02-06  Keith Miller  <keith_miller@apple.com>

        put_to_scope/get_from_scope should not cache lexical scopes when expecting a global object
        https://bugs.webkit.org/show_bug.cgi?id=182549
        <rdar://problem/36189995>

        Reviewed by Saam Barati.

        Previously, the llint/baseline caching for put_to_scope and
        get_from_scope would cache lexical environments when the
        varInjectionWatchpoint had been fired for global properties. Code
        in the DFG does not follow this same assumption so we could
        potentially return the wrong result. Additionally, the baseline
        would write barrier the global object rather than the lexical
        enviroment object. This patch makes it so that we do not cache
        anything other than the global object for when the resolve type is
        GlobalPropertyWithVarInjectionChecks or GlobalProperty.

        * assembler/MacroAssembler.cpp:
        (JSC::MacroAssembler::jitAssert):
        * assembler/MacroAssembler.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emit_op_get_from_scope):
        (JSC::JIT::emit_op_put_to_scope):
        * runtime/CommonSlowPaths.h:
        (JSC::CommonSlowPaths::tryCachePutToScopeGlobal):
        (JSC::CommonSlowPaths::tryCacheGetFromScopeGlobal):
        * runtime/Options.h:

2018-02-11  Guillaume Emont  <guijemont@igalia.com>

        [MIPS] JSC needs to be built with -latomic
        https://bugs.webkit.org/show_bug.cgi?id=182610

        Reviewed by Žan Doberšek.

        Since r228149, on MIPS we need to link with -latomic, because
        __atomic_fetch_add_8 is not available as a compiler intrinsic.

        * CMakeLists.txt:

2018-01-28  Filip Pizlo  <fpizlo@apple.com>

        Global objects should be able to use TLCs to allocate from different blocks from each other
        https://bugs.webkit.org/show_bug.cgi?id=182227

        Reviewed by JF Bastien.
        
        This uses TLCs to create at least `minimumDistanceBetweenCellsFromDifferenOrigins` bytes of
        distance between objects from different origins, using the following combination of things. For
        short lets refer to that constant as K.
        
        - Since r227721, LargeAllocation puts K bytes padding at the end of each allocation.
        
        - Since r227718, MarkedBlock puts at least K bytes in its footer.
        
        - Since r227617, global objects can have their own TLCs, which make them allocate from a
          different set of blocks than other global objects. The TLC of a global object comes into
          effect when you enter the VM via that global object.
        
        - With this change, TLCs and blocks both have security origins. A TLC will only use blocks that
          share the same security origin or empty blocks (in which case we zero the block and change
          its security origin).
        
        WebCore determines the TLC-GlobalObject mapping. By default, global objects would simply use
        the VM's default TLC. WebCore makes it so that DOM windows (but not worker global objects) get
        a TLC based on their document's SecurityOrigin.
        
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * heap/BlockDirectory.cpp:
        (JSC::BlockDirectory::findBlockForAllocation):
        (JSC::BlockDirectory::prepareForAllocation):
        * heap/BlockDirectory.h:
        * heap/LocalAllocator.cpp:
        (JSC::LocalAllocator::LocalAllocator):
        (JSC::LocalAllocator::reset):
        (JSC::LocalAllocator::~LocalAllocator):
        (JSC::LocalAllocator::allocateSlowCase):
        (JSC::LocalAllocator::tryAllocateWithoutCollecting):
        * heap/LocalAllocator.h:
        (JSC::LocalAllocator::tlc const):
        * heap/MarkStackMergingConstraint.cpp:
        * heap/MarkStackMergingConstraint.h:
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::Handle::associateWithOrigin):
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::Handle::securityOriginToken const):
        * heap/SecurityOriginToken.cpp: Added.
        (JSC::uniqueSecurityOriginToken):
        * heap/SecurityOriginToken.h: Added.
        * heap/ThreadLocalCache.cpp:
        (JSC::ThreadLocalCache::create):
        (JSC::ThreadLocalCache::ThreadLocalCache):
        (JSC::ThreadLocalCache::allocateData):
        (JSC::ThreadLocalCache::installSlow):
        * heap/ThreadLocalCache.h:
        (JSC::ThreadLocalCache::securityOriginToken const):
        * heap/ThreadLocalCacheInlines.h:
        (JSC::ThreadLocalCache::install):
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::JSGlobalObject):
        (JSC::JSGlobalObject::createThreadLocalCache):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::threadLocalCache):
        (JSC::JSGlobalObject::threadLocalCache const): Deleted.
        * runtime/VMEntryScope.cpp:
        (JSC::VMEntryScope::VMEntryScope):
        (JSC::VMEntryScope::~VMEntryScope):
        * runtime/VMEntryScope.h:

2018-02-05  Don Olmstead  <don.olmstead@sony.com>

        JavaScriptCore files should not be included relatively
        https://bugs.webkit.org/show_bug.cgi?id=182452

        Reviewed by Keith Miller.

        * API/JSCallbackConstructor.h:
        * CMakeLists.txt:
        * disassembler/ARM64Disassembler.cpp:
        * disassembler/ARMv7Disassembler.cpp:
        * heap/LockDuringMarking.h:
        * inspector/InjectedScriptBase.h:
        * inspector/InjectedScriptHost.h:
        * inspector/JavaScriptCallFrame.h:
        * inspector/ScriptArguments.h:
        * inspector/ScriptDebugListener.h:
        * inspector/ScriptDebugServer.h:
        * inspector/agents/InspectorAgent.h:
        * inspector/agents/InspectorConsoleAgent.h:
        * inspector/agents/InspectorDebuggerAgent.h:
        * inspector/agents/InspectorHeapAgent.h:
        * inspector/agents/InspectorRuntimeAgent.h:
        * inspector/agents/InspectorScriptProfilerAgent.h:
        * runtime/RegExp.h:

2018-02-05  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r228012.
        https://bugs.webkit.org/show_bug.cgi?id=182493

        "It regressed ARES-6 by 2-4%" (Requested by saamyjoon on
        #webkit).

        Reverted changeset:

        "[JSC] Clean up ArraySpeciesCreate"
        https://bugs.webkit.org/show_bug.cgi?id=182434
        https://trac.webkit.org/changeset/228012

2018-02-02  Ryan Haddad  <ryanhaddad@apple.com>

        Rebaseline bindings generator tests after r228032.
        https://bugs.webkit.org/show_bug.cgi?id=182445

        Unreviewed test gardening.

        * Scripts/tests/builtins/expected/WebCoreJSBuiltins.h-result:

2018-02-02  Saam Barati  <sbarati@apple.com>

        Make various DFG_ASSERTs provide more data to WTFCrashWithInfo
        https://bugs.webkit.org/show_bug.cgi?id=182453
        <rdar://problem/37174236>

        Reviewed by JF Bastien and Mark Lam.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGArgumentsEliminationPhase.cpp:
        * dfg/DFGArgumentsUtilities.cpp:
        (JSC::DFG::emitCodeToGetArgumentsArrayLength):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupChecksInBlock):
        * dfg/DFGFlowIndexing.h:
        (JSC::DFG::FlowIndexing::shadowIndex const):
        * dfg/DFGLICMPhase.cpp:
        (JSC::DFG::LICMPhase::run):
        (JSC::DFG::LICMPhase::attemptHoist):
        * dfg/DFGLoopPreHeaderCreationPhase.cpp:
        (JSC::DFG::LoopPreHeaderCreationPhase::run):
        * dfg/DFGPutStackSinkingPhase.cpp:
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileArithAbs):
        (JSC::DFG::SpeculativeJIT::compileArithRounding):
        (JSC::DFG::SpeculativeJIT::compileToPrimitive):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::fillJSValue):
        (JSC::DFG::SpeculativeJIT::fillSpeculateInt32Internal):
        (JSC::DFG::SpeculativeJIT::fillSpeculateInt32Strict):
        (JSC::DFG::SpeculativeJIT::fillSpeculateInt52):
        (JSC::DFG::SpeculativeJIT::fillSpeculateDouble):
        (JSC::DFG::SpeculativeJIT::fillSpeculateBoolean):
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGStoreBarrierClusteringPhase.cpp:
        * dfg/DFGStoreBarrierInsertionPhase.cpp:
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileGetStack):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithClz32):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithAbs):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithRound):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithFloor):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithCeil):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithTrunc):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithNegate):
        (JSC::FTL::DFG::LowerDFGToB3::compilePutById):
        (JSC::FTL::DFG::LowerDFGToB3::compileGetIndexedPropertyStorage):
        (JSC::FTL::DFG::LowerDFGToB3::compileGetByVal):
        (JSC::FTL::DFG::LowerDFGToB3::compileStringFromCharCode):
        (JSC::FTL::DFG::LowerDFGToB3::compileMultiPutByOffset):
        (JSC::FTL::DFG::LowerDFGToB3::compileCompareEq):
        (JSC::FTL::DFG::LowerDFGToB3::compileCompareStrictEq):
        (JSC::FTL::DFG::LowerDFGToB3::compileIn):
        (JSC::FTL::DFG::LowerDFGToB3::compare):
        (JSC::FTL::DFG::LowerDFGToB3::switchStringRecurse):
        (JSC::FTL::DFG::LowerDFGToB3::lowInt32):
        (JSC::FTL::DFG::LowerDFGToB3::lowInt52):
        (JSC::FTL::DFG::LowerDFGToB3::lowCell):
        (JSC::FTL::DFG::LowerDFGToB3::lowBoolean):
        (JSC::FTL::DFG::LowerDFGToB3::lowDouble):
        (JSC::FTL::DFG::LowerDFGToB3::lowJSValue):

2018-02-02  Don Olmstead  <don.olmstead@sony.com>

        JS Builtins should include JavaScriptCore headers directly
        https://bugs.webkit.org/show_bug.cgi?id=182445

        Reviewed by Yusuke Suzuki.

        * Scripts/builtins/builtins_generator.py:
        * Scripts/tests/builtins/expected/WebCore-AnotherGuardedInternalBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-ArbitraryConditionalGuard-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-GuardedBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-GuardedInternalBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-UnguardedBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-xmlCasingTest-Separate.js-result:

2018-02-02  Saam Barati  <sbarati@apple.com>

        When BytecodeParser inserts Unreachable after ForceOSRExit it needs to update ArgumentPositions for Flushes it inserts
        https://bugs.webkit.org/show_bug.cgi?id=182368
        <rdar://problem/36932466>

        Reviewed by Mark Lam.

        When preserving liveness when inserting Unreachable nodes after ForceOSRExit,
        we must add the VariableAccessData to the given argument position. Otherwise,
        we may end up with a VariableAccessData that doesn't respect the shouldNeverUnbox bit.
        If we end up with such a situation, it can lead to invalid IR after the
        arguments elimination phase optimizes a GetByVal to a GetStack.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::flushImpl):
        (JSC::DFG::ByteCodeParser::flushForTerminalImpl):
        (JSC::DFG::ByteCodeParser::flush):
        (JSC::DFG::ByteCodeParser::flushForTerminal):
        (JSC::DFG::ByteCodeParser::InlineStackEntry::InlineStackEntry):
        (JSC::DFG::ByteCodeParser::parse):

2018-02-02  Mark Lam  <mark.lam@apple.com>

        More ARM64_32 fixes.
        https://bugs.webkit.org/show_bug.cgi?id=182441
        <rdar://problem/37162310>

        Reviewed by Dan Bernstein.

        I also disabled more dynamicPoisoning code in ARM64_32.  This code assumes a
        64-bit pointer which is not applicable here.

        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitDynamicPoison):
        (JSC::AssemblyHelpers::emitDynamicPoisonOnLoadedType):
        (JSC::AssemblyHelpers::emitDynamicPoisonOnType):

2018-02-02  Saam Barati  <sbarati@apple.com>

        MapHash should return true to doesGC in the DFG depending on useKind because it might resolve a rope
        https://bugs.webkit.org/show_bug.cgi?id=182402

        Reviewed by Yusuke Suzuki.

        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):

2018-02-02  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Clean up ArraySpeciesCreate
        https://bugs.webkit.org/show_bug.cgi?id=182434

        Reviewed by Saam Barati.

        We have duplicate code in filter, map, concatSlowPath.
        This patch creates a new global private function @arraySpeciesCreate,
        and use it.

        * builtins/ArrayPrototype.js:
        (globalPrivate.arraySpeciesCreate):
        (filter):
        (map):
        (globalPrivate.concatSlowPath):

2018-02-01  Mark Lam  <mark.lam@apple.com>

        Fix broken bounds check in FTL's compileGetMyArgumentByVal().
        https://bugs.webkit.org/show_bug.cgi?id=182419
        <rdar://problem/37044945>

        Reviewed by Saam Barati.

        In compileGetMyArgumentByVal(), it computes:
            limit = m_out.sub(limit, m_out.constInt32(m_node->numberOfArgumentsToSkip()));
            ...
            LValue isOutOfBounds = m_out.aboveOrEqual(originalIndex, limit);

        where the original "limit" is the number of arguments passed in by the caller.
        If the original limit is less than numberOfArgumentsToSkip, the resultant limit
        will be a large unsigned number.  As a result, this will defeat the bounds check
        that follows it.

        Note: later on in compileGetMyArgumentByVal(), we have to adjust adjust the index
        value by adding numberOfArgumentsToSkip to it, in order to determine the actual
        entry in the arguments array to get.

        The fix is to just add numberOfArgumentsToSkip to index upfront (instead of
        subtracting it from limit), and doing an overflow speculation check on that
        addition before doing the bounds check.

        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileGetMyArgumentByVal):

2018-02-01  Keith Miller  <keith_miller@apple.com>

        Fix crashes due to mishandling custom sections.
        https://bugs.webkit.org/show_bug.cgi?id=182404
        <rdar://problem/36935863>

        Reviewed by Saam Barati.

        This also cleans up some of our validation code. We also
        mistakenly, allowed unknown (different from custom sections with
        id: 0) section ids.

        * wasm/WasmModuleParser.cpp:
        (JSC::Wasm::ModuleParser::parse):
        * wasm/WasmModuleParser.h:
        * wasm/WasmSections.h:
        (JSC::Wasm::isKnownSection):
        (JSC::Wasm::decodeSection):
        (JSC::Wasm::validateOrder):
        (JSC::Wasm::makeString):
        (JSC::Wasm::isValidSection): Deleted.

2018-02-01  Michael Catanzaro  <mcatanzaro@igalia.com>

        -Wreturn-type warning in DFGObjectAllocationSinkingPhase.cpp
        https://bugs.webkit.org/show_bug.cgi?id=182389

        Reviewed by Yusuke Suzuki.

        Fix the warning.

        As a bonus, remove a couple unreachable breaks for good measure.

        * dfg/DFGObjectAllocationSinkingPhase.cpp:

2018-02-01  Chris Dumez  <cdumez@apple.com>

        Queue a microtask when a waitUntil() promise is settled
        https://bugs.webkit.org/show_bug.cgi?id=182372
        <rdar://problem/37101019>

        Reviewed by Mark Lam.

        Export a symbol so it can be used in WebCore.

        * runtime/JSGlobalObject.h:

2018-01-31  Don Olmstead  <don.olmstead@sony.com>

        [CMake] Make JavaScriptCore headers copies
        https://bugs.webkit.org/show_bug.cgi?id=182303

        Reviewed by Alex Christensen.

        * CMakeLists.txt:
        * PlatformGTK.cmake:
        * PlatformJSCOnly.cmake:
        * PlatformMac.cmake:
        * PlatformWPE.cmake:
        * PlatformWin.cmake:
        * shell/CMakeLists.txt:
        * shell/PlatformWin.cmake:

2018-01-31  Saam Barati  <sbarati@apple.com>

        Replace tryLargeMemalignVirtual with tryLargeZeroedMemalignVirtual and use it to allocate large zeroed memory in Wasm
        https://bugs.webkit.org/show_bug.cgi?id=182064
        <rdar://problem/36840132>

        Reviewed by Geoffrey Garen.

        This patch switches WebAssembly Memory to always use bmalloc's
        zeroed virtual allocation API. This makes it so that we don't
        dirty the memory to zero it. It's a huge compile time speedup
        on WasmBench on iOS.

        * wasm/WasmMemory.cpp:
        (JSC::Wasm::Memory::create):
        (JSC::Wasm::Memory::~Memory):
        (JSC::Wasm::Memory::addressIsInActiveFastMemory):
        (JSC::Wasm::Memory::grow):
        (JSC::Wasm::commitZeroPages): Deleted.

2018-01-31  Mark Lam  <mark.lam@apple.com>

        Build fix for CLoop after r227874.
        https://bugs.webkit.org/show_bug.cgi?id=182155
        <rdar://problem/36286266>

        Not reviewed.

        Just needed support for lea of a LabelReference in cloop.rb (just like those
        added for arm64.rb and x86.rb).

        * offlineasm/cloop.rb:

2018-01-31  Keith Miller  <keith_miller@apple.com>

        Canonicalize aquiring the JSCell lock.
        https://bugs.webkit.org/show_bug.cgi?id=182320

        Reviewed by Michael Saboff.

        It's currently kinda annoying to figure out where
        we aquire the a JSCell's lock. This patch adds a
        helper to make it easier to grep...

        * bytecode/UnlinkedCodeBlock.cpp:
        (JSC::UnlinkedCodeBlock::visitChildren):
        (JSC::UnlinkedCodeBlock::setInstructions):
        (JSC::UnlinkedCodeBlock::shrinkToFit):
        * runtime/ErrorInstance.cpp:
        (JSC::ErrorInstance::finishCreation):
        (JSC::ErrorInstance::materializeErrorInfoIfNeeded):
        (JSC::ErrorInstance::visitChildren):
        * runtime/JSArray.cpp:
        (JSC::JSArray::shiftCountWithArrayStorage):
        (JSC::JSArray::unshiftCountWithArrayStorage):
        * runtime/JSCell.h:
        (JSC::JSCell::cellLock):
        * runtime/JSObject.cpp:
        (JSC::JSObject::visitButterflyImpl):
        (JSC::JSObject::convertContiguousToArrayStorage):
        * runtime/JSPropertyNameEnumerator.cpp:
        (JSC::JSPropertyNameEnumerator::visitChildren):
        * runtime/SparseArrayValueMap.cpp:
        (JSC::SparseArrayValueMap::add):
        (JSC::SparseArrayValueMap::remove):
        (JSC::SparseArrayValueMap::visitChildren):

2018-01-31  Saam Barati  <sbarati@apple.com>

        JSC incorrectly interpreting script, sets Global Property instead of Global Lexical variable (LiteralParser / JSONP path)
        https://bugs.webkit.org/show_bug.cgi?id=182074
        <rdar://problem/36846261>

        Reviewed by Mark Lam.

        This patch teaches the JSONP evaluator about the global lexical environment.
        Before, it was using the global object as the global scope, but that's wrong.
        The global lexical environment is the first node in the global scope chain.

        * interpreter/Interpreter.cpp:
        (JSC::Interpreter::executeProgram):
        * jsc.cpp:
        (GlobalObject::finishCreation):
        (shellSupportsRichSourceInfo):
        (functionDisableRichSourceInfo):
        * runtime/LiteralParser.cpp:
        (JSC::LiteralParser<CharType>::tryJSONPParse):
        * runtime/LiteralParser.h:

2018-01-31  Saam Barati  <sbarati@apple.com>

        clean up pushToSaveImmediateWithoutTouchingRegisters a bit
        https://bugs.webkit.org/show_bug.cgi?id=181774

        Reviewed by JF Bastien.

        This function on ARM64 was considering what to do with the scratch
        register. And conditionally invalidated what was in it. This is not
        relevant though, since the function always recovers what was in that
        register. This patch just switches it to using dataTempRegister
        directly and updates the comment to describe why it can do so safely.

        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::pushToSaveImmediateWithoutTouchingRegisters):

2018-01-30  Mark Lam  <mark.lam@apple.com>

        Apply poisoning to TypedArray vector pointers.
        https://bugs.webkit.org/show_bug.cgi?id=182155
        <rdar://problem/36286266>

        Reviewed by JF Bastien.

        The TypeArray's vector pointer is now poisoned.  The poison value is chosen based
        on a TypeArray's jsType.  The JSType must be between FirstTypedArrayType and
        LastTypedArrayType.  At runtime, we enforce that the index is well-behaved by
        masking it against TypedArrayPoisonIndexMask.  TypedArrayPoisonIndexMask (16) is
        the number of TypedArray types (10) rounded up to the next power of 2.
        Accordingly, we reserve an array of TypedArrayPoisonIndexMask poisons so that we
        can use index masking on the index, and be guaranteed that the masked index will
        be within bounds of the poisons array.

        1. Fixed both DFG and FTL versions of compileGetTypedArrayByteOffset() to not
           do any unnecessary work if the TypedArray vector is null.

           FTL's cagedMayBeNull() is no longer needed because it is only used by
           compileGetTypedArrayByteOffset(), and we need to enhance it to handle unpoisoning
           in a TypedArray specific way.  So, might as well do the work inline in
           compileGetTypedArrayByteOffset() instead.

        2. Removed an unnecessary null-check in DFGSpeculativeJIT's compileNewTypedArrayWithSize()
           because there's already a null check above it that ensures that sizeGPR is
           never null.

        3. In LLInt's _llint_op_get_by_val, move the TypedArray length check before the
           loading of the vector for unpoisoning and uncaging.  We don't need the vector
           if the length is 0.

        Implementation notes on the need to null check the TypeArray vector:

        1. DFG::SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds() does not need a
           m_poisonedVector null check because the function is a null check.

        2. DFG::SpeculativeJIT::compileGetIndexedPropertyStorage() does not need a
           m_poisonedVector null check because it is followed by a call to
           cageTypedArrayStorage() which assumes that storageReg cannot be null.

        3. DFG::SpeculativeJIT::compileGetTypedArrayByteOffset() already has a
           m_poisonedVector null check.

        4. DFG::SpeculativeJIT::compileNewTypedArrayWithSize() does not need a vector null
           check because the poisoning code is preceded by a sizeGPR null check, which
           ensures that the storageGPR (vector to be poisoned) is not null.

        5. FTL's compileGetIndexedPropertyStorage() does not need a m_poisonedVector null
           check because it is followed by a call to caged() which assumes that the
           vector cannot be null.

        6. FTL's compileGetTypedArrayByteOffset() already has a m_poisonedVector null check.

        7. FTL's compileNewTypedArray() does not need a vector null check because the
           poisoning code is preceded by a size null check, which ensures that the
           storage (vector to be poisoned) is not null.

        8. FTL's speculateTypedArrayIsNotNeutered() does not need a
           m_poisonedVector null check because the function is a null check.

        9. IntrinsicGetterAccessCase::emitIntrinsicGetter()'s TypedArrayByteOffsetIntrinsic
           case needs a null check so that it does not try to unpoison a null vector.

        10. JIT::emitIntTypedArrayGetByVal() does not need a vector null check because
            we already do a length check even before loading the vector.

        11. JIT::emitFloatTypedArrayGetByVal() does not need a vector null check because
            we already do a length check even before loading the vector.

        12. JIT::emitIntTypedArrayPutByVal() does not need a vector null check because
            we already do a length check even before loading the vector.

        13. JIT::emitFloatTypedArrayPutByVal() does not need a vector null check because
            we already do a length check even before loading the vector.

        14. LLInt's loadTypedArrayCaged() does not need a vector null check because its
            client will do a TypedArray length check before calling it.

        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::checkArray):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::hasArrayMode):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds):
        (JSC::DFG::SpeculativeJIT::compileGetIndexedPropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileGetTypedArrayByteOffset):
        (JSC::DFG::SpeculativeJIT::compileNewTypedArrayWithSize):
        * ftl/FTLAbstractHeapRepository.h:
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileGetIndexedPropertyStorage):
        (JSC::FTL::DFG::LowerDFGToB3::compileGetTypedArrayByteOffset):
        (JSC::FTL::DFG::LowerDFGToB3::compileNewTypedArray):
        (JSC::FTL::DFG::LowerDFGToB3::speculateTypedArrayIsNotNeutered):
        (JSC::FTL::DFG::LowerDFGToB3::cagedMayBeNull): Deleted.
        * jit/IntrinsicEmitter.cpp:
        (JSC::IntrinsicGetterAccessCase::emitIntrinsicGetter):
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emitIntTypedArrayGetByVal):
        (JSC::JIT::emitFloatTypedArrayGetByVal):
        (JSC::JIT::emitIntTypedArrayPutByVal):
        (JSC::JIT::emitFloatTypedArrayPutByVal):
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter64.asm:
        * offlineasm/arm64.rb:
        * offlineasm/x86.rb:
        * runtime/CagedBarrierPtr.h:
        * runtime/JSArrayBufferView.cpp:
        (JSC::JSArrayBufferView::JSArrayBufferView):
        (JSC::JSArrayBufferView::finalize):
        (JSC::JSArrayBufferView::neuter):
        * runtime/JSArrayBufferView.h:
        (JSC::JSArrayBufferView::vector const):
        (JSC::JSArrayBufferView::offsetOfPoisonedVector):
        (JSC::JSArrayBufferView::poisonFor):
        (JSC::JSArrayBufferView::Poison::key):
        (JSC::JSArrayBufferView::offsetOfVector): Deleted.
        * runtime/JSCPoison.cpp:
        (JSC::initializePoison):
        * runtime/JSCPoison.h:
        * runtime/JSGenericTypedArrayViewInlines.h:
        (JSC::JSGenericTypedArrayView<Adaptor>::estimatedSize):
        (JSC::JSGenericTypedArrayView<Adaptor>::visitChildren):
        (JSC::JSGenericTypedArrayView<Adaptor>::slowDownAndWasteMemory):
        * runtime/JSObject.h:

2018-01-30  Fujii Hironori  <Hironori.Fujii@sony.com>

        [Win] Warning fix.
        https://bugs.webkit.org/show_bug.cgi?id=177007

        Reviewed by Yusuke Suzuki.

        * interpreter/StackVisitor.cpp:
        (JSC::StackVisitor::Frame::dump const):
        Changed the type of locationRawBits from unsigned to uintptr_t.
        * runtime/IntlNumberFormat.cpp:
        (JSC::IntlNumberFormat::createNumberFormat):
        Initialize 'style' to avoid potentially uninitialized local variable warning.

2018-01-29  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Implement trimStart and trimEnd
        https://bugs.webkit.org/show_bug.cgi?id=182233

        Reviewed by Mark Lam.

        String.prototype.{trimStart,trimEnd} are now stage 3[1].
        String.prototype.{trimLeft,trimRight} are alias to these functions.

        We rename these functions to trimStart and trimEnd, and put them as
        trimLeft and trimRight too.

        [1]: https://tc39.github.io/proposal-string-left-right-trim/

        * runtime/StringPrototype.cpp:
        (JSC::StringPrototype::finishCreation):
        (JSC::trimString):
        (JSC::stringProtoFuncTrim):
        (JSC::stringProtoFuncTrimStart):
        (JSC::stringProtoFuncTrimEnd):
        (JSC::stringProtoFuncTrimLeft): Deleted.
        (JSC::stringProtoFuncTrimRight): Deleted.

2018-01-29  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Relax line terminators in String to make JSON subset of JS
        https://bugs.webkit.org/show_bug.cgi?id=182232

        Reviewed by Keith Miller.

        "Subsume JSON" spec is now stage 3[1]. Before this spec change,
        JSON can accept \u2028 / \u2029 in string while JS cannot do that.
        It accidentally made JSON non subset of JS.

        Now we extend our JS string to accept \u2028 / \u2029 to make JSON
        subset of JS in this spec change.

        [1]: https://github.com/tc39/proposal-json-superset

        * parser/Lexer.cpp:
        (JSC::Lexer<T>::parseStringSlowCase):

2018-01-29  Jiewen Tan  <jiewen_tan@apple.com>

        [WebAuthN] Add a compile-time feature flag
        https://bugs.webkit.org/show_bug.cgi?id=182211
        <rdar://problem/36936365>

        Reviewed by Brent Fulgham.

        * Configurations/FeatureDefines.xcconfig:

2018-01-29  Michael Saboff  <msaboff@apple.com>

        REGRESSION (r227341): DFG_ASSERT failure at JSC::DFG::AtTailAbstractState::forNode()
        https://bugs.webkit.org/show_bug.cgi?id=182249

        Reviewed by Keith Miller.

        Changed clobberize() handling of CompareEq, et al to properly handle comparisons between
        Untyped and Object values when compared against built in types.  Such comparisons can
        invoke toNumber() or other methods.

        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):

2018-01-29  Matt Lewis  <jlewis3@apple.com>

        Unreviewed, rolling out r227725.

        This caused internal failures.

        Reverted changeset:

        "JSC Sampling Profiler: Detect tester and testee when sampling
        in RegExp JIT"
        https://bugs.webkit.org/show_bug.cgi?id=152729
        https://trac.webkit.org/changeset/227725

2018-01-29  Yusuke Suzuki  <utatane.tea@gmail.com>

        JSC Sampling Profiler: Detect tester and testee when sampling in RegExp JIT
        https://bugs.webkit.org/show_bug.cgi?id=152729

        Reviewed by Saam Barati.

        This patch extends SamplingProfiler to recognize JIT RegExp execution. We record
        executing RegExp in VM so that SamplingProfiler can detect it. This is better
        than the previous VM::isExecutingInRegExpJIT flag approach since

        1. isExecutingInRegExpJIT is set after starting executing JIT RegExp code. Thus,
        if we suspend the thread just before executing this flag, or just after clearing
        this flag, SamplingProfiler gets invalid frame, and frame validation fails. We
        should set such a flag before and after executing JIT RegExp code.

        2. This removes VM dependency from YarrJIT which is not essential one.

        We add ExecutionContext enum to RegExp::matchInline not to mark execution if it
        is done in non JS thread.

        * bytecode/BytecodeDumper.cpp:
        (JSC::regexpName):
        (JSC::BytecodeDumper<Block>::dumpRegExps):
        (JSC::regexpToSourceString): Deleted.
        * heap/Heap.cpp:
        (JSC::Heap::addCoreConstraints):
        * runtime/RegExp.cpp:
        (JSC::RegExp::compile):
        (JSC::RegExp::match):
        (JSC::RegExp::matchConcurrently):
        (JSC::RegExp::compileMatchOnly):
        (JSC::RegExp::toSourceString const):
        * runtime/RegExp.h:
        * runtime/RegExpInlines.h:
        (JSC::RegExp::matchInline):
        * runtime/RegExpMatchesArray.h:
        (JSC::createRegExpMatchesArray):
        * runtime/SamplingProfiler.cpp:
        (JSC::SamplingProfiler::SamplingProfiler):
        (JSC::SamplingProfiler::timerLoop):
        (JSC::SamplingProfiler::takeSample):
        (JSC::SamplingProfiler::processUnverifiedStackTraces):
        (JSC::SamplingProfiler::StackFrame::nameFromCallee):
        (JSC::SamplingProfiler::StackFrame::displayName):
        (JSC::SamplingProfiler::StackFrame::displayNameForJSONTests):
        (JSC::SamplingProfiler::StackFrame::functionStartLine):
        (JSC::SamplingProfiler::StackFrame::functionStartColumn):
        (JSC::SamplingProfiler::StackFrame::sourceID):
        (JSC::SamplingProfiler::StackFrame::url):
        (WTF::printInternal):
        (JSC::SamplingProfiler::~SamplingProfiler): Deleted.
        * runtime/SamplingProfiler.h:
        * runtime/VM.h:
        * yarr/YarrJIT.cpp:
        (JSC::Yarr::YarrGenerator::generateEnter):
        (JSC::Yarr::YarrGenerator::generateReturn):
        (JSC::Yarr::YarrGenerator::YarrGenerator):
        (JSC::Yarr::jitCompile):
        * yarr/YarrJIT.h:

2018-01-29  Yusuke Suzuki  <utatane.tea@gmail.com>

        [DFG][FTL] WeakMap#set should have DFG node
        https://bugs.webkit.org/show_bug.cgi?id=180015

        Reviewed by Saam Barati.

        This patch adds WeakMapSet and WeakSetAdd DFG nodes to handle them efficiently in DFG and FTL.
        We also define CSE rules for them. Now, WeakMapSet and WeakSetAdd can offer the results of
        the subsequent WeakMapGet if CSE allows.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::addVarArgChild):
        (JSC::DFG::ByteCodeParser::handleIntrinsicCall):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        WeakMap operations do not cause GC.

        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGNodeType.h:
        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileWeakSetAdd):
        (JSC::DFG::SpeculativeJIT::compileWeakMapSet):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileWeakSetAdd):
        (JSC::FTL::DFG::LowerDFGToB3::compileWeakMapSet):
        * jit/JITOperations.h:
        * runtime/Intrinsic.cpp:
        (JSC::intrinsicName):
        * runtime/Intrinsic.h:
        * runtime/WeakMapPrototype.cpp:
        (JSC::WeakMapPrototype::finishCreation):
        * runtime/WeakSetPrototype.cpp:
        (JSC::WeakSetPrototype::finishCreation):

2018-01-28  Filip Pizlo  <fpizlo@apple.com>

        LargeAllocation should do the same distancing as MarkedBlock
        https://bugs.webkit.org/show_bug.cgi?id=182226

        Reviewed by Saam Barati.

        This makes LargeAllocation do the same exact distancing that MarkedBlock promises to do.
        
        To make that possible, this patch first makes MarkedBlock know exactly how much distancing it
        is doing:
        
        - I've rationalized the payloadSize calculation. In particular, I made MarkedSpace use the
          calculation done in MarkedBlock. MarkedSpace used to do the math a different way. This
          keeps the old way just for a static_assert.
        
        - The promised amount of distancing is now codified in HeapCell.h as
          minimumDistanceBetweenCellsFromDifferentOrigins. We assert that the footer size is at least
          as big as this. I didn't want to just use footer size for this constant because then, if
          you increased the size of the footer, you'd also add padding to every large allocation.
        
        Then this patch just adds minimumDistanceBetweenCellsFromDifferentOrigins to each large
        allocation. It also zeroes that slice of memory to prevent any information leaks that way.
        
        This is perf neutral. Large allocations start out at ~8000 bytes. The amount of padding is
        ~300 bytes. That's 3.75% space overhead for objects that are ~8000 bytes, zero overhead for
        smaller objects, and diminishing overhead for larger objects. We allocate very few large
        objects, so we shouldn't have any real space overhead from this.

        * heap/HeapCell.h:
        * heap/LargeAllocation.cpp:
        (JSC::LargeAllocation::tryCreate):
        * heap/MarkedBlock.h:
        * heap/MarkedSpace.h:

2018-01-27  Filip Pizlo  <fpizlo@apple.com>

        Make MarkedBlock::Footer bigger
        https://bugs.webkit.org/show_bug.cgi?id=182220

        Reviewed by JF Bastien.
        
        This makes the block footer larger by moving the newlyAllocated bits from the handle into
        the footer.
        
        It used to be profitable to put anything we could into the handle because that would free up
        payload space inside the block. But now that we want to use the footer for padding, it's
        profitable to put GC state information - especially data that is used by the GC itself and so
        is not useful for a Spectre attack - into the footer to increase object distancing.

        * heap/CellContainer.cpp:
        (JSC::CellContainer::isNewlyAllocated const):
        * heap/IsoCellSet.cpp:
        (JSC::IsoCellSet::sweepToFreeList):
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::Handle::Handle):
        (JSC::MarkedBlock::Footer::Footer):
        (JSC::MarkedBlock::Handle::stopAllocating):
        (JSC::MarkedBlock::Handle::lastChanceToFinalize):
        (JSC::MarkedBlock::Handle::resumeAllocating):
        (JSC::MarkedBlock::aboutToMarkSlow):
        (JSC::MarkedBlock::resetAllocated):
        (JSC::MarkedBlock::Handle::resetAllocated): Deleted.
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::newlyAllocatedVersion const):
        (JSC::MarkedBlock::isNewlyAllocated):
        (JSC::MarkedBlock::setNewlyAllocated):
        (JSC::MarkedBlock::clearNewlyAllocated):
        (JSC::MarkedBlock::newlyAllocated const):
        (JSC::MarkedBlock::Handle::newlyAllocatedVersion const): Deleted.
        (JSC::MarkedBlock::Handle::isNewlyAllocated): Deleted.
        (JSC::MarkedBlock::Handle::setNewlyAllocated): Deleted.
        (JSC::MarkedBlock::Handle::clearNewlyAllocated): Deleted.
        (JSC::MarkedBlock::Handle::newlyAllocated const): Deleted.
        * heap/MarkedBlockInlines.h:
        (JSC::MarkedBlock::isNewlyAllocatedStale const):
        (JSC::MarkedBlock::hasAnyNewlyAllocated):
        (JSC::MarkedBlock::Handle::isLive):
        (JSC::MarkedBlock::Handle::specializedSweep):
        (JSC::MarkedBlock::Handle::newlyAllocatedMode):
        (JSC::MarkedBlock::Handle::isNewlyAllocatedStale const): Deleted.
        (JSC::MarkedBlock::Handle::hasAnyNewlyAllocated): Deleted.
        * heap/MarkedSpace.cpp:
        (JSC::MarkedSpace::endMarking):
        * heap/SlotVisitor.cpp:
        (JSC::SlotVisitor::appendJSCellOrAuxiliary):

2018-01-27  Filip Pizlo  <fpizlo@apple.com>

        MarkedBlock should have a footer instead of a header
        https://bugs.webkit.org/show_bug.cgi?id=182217

        Reviewed by JF Bastien.
        
        This moves the MarkedBlock's meta-data from the header to the footer. This doesn't really
        change anything except for some compile-time constants, so it should not affect performance.
        
        This change is to help protect against Spectre attacks on structure checks, which allow for
        small-offset out-of-bounds access. By putting the meta-data at the end of the block, small
        OOBs will only get to other objects in the same block or the block footer. The block footer
        is not super interesting. So, if we combine this with the TLC change (r227617), this means we
        can use blocks as the mechanism of achieving distance between objects from different origins.
        We just need to avoid ever putting objects from different origins in the same block. That's
        what bug 181636 is about.
        
        * heap/BlockDirectory.cpp:
        (JSC::blockHeaderSize): Deleted.
        (JSC::BlockDirectory::blockSizeForBytes): Deleted.
        * heap/BlockDirectory.h:
        * heap/HeapUtil.h:
        (JSC::HeapUtil::findGCObjectPointersForMarking):
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::MarkedBlock):
        (JSC::MarkedBlock::~MarkedBlock):
        (JSC::MarkedBlock::Footer::Footer):
        (JSC::MarkedBlock::Footer::~Footer):
        (JSC::MarkedBlock::Handle::stopAllocating):
        (JSC::MarkedBlock::Handle::lastChanceToFinalize):
        (JSC::MarkedBlock::Handle::resumeAllocating):
        (JSC::MarkedBlock::aboutToMarkSlow):
        (JSC::MarkedBlock::resetMarks):
        (JSC::MarkedBlock::assertMarksNotStale):
        (JSC::MarkedBlock::Handle::didConsumeFreeList):
        (JSC::MarkedBlock::markCount):
        (JSC::MarkedBlock::clearHasAnyMarked):
        (JSC::MarkedBlock::Handle::didAddToDirectory):
        (JSC::MarkedBlock::Handle::didRemoveFromDirectory):
        (JSC::MarkedBlock::Handle::sweep):
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::markingVersion const):
        (JSC::MarkedBlock::lock):
        (JSC::MarkedBlock::subspace const):
        (JSC::MarkedBlock::footer):
        (JSC::MarkedBlock::footer const):
        (JSC::MarkedBlock::handle):
        (JSC::MarkedBlock::handle const):
        (JSC::MarkedBlock::Handle::blockFooter):
        (JSC::MarkedBlock::isAtomAligned):
        (JSC::MarkedBlock::Handle::cellAlign):
        (JSC::MarkedBlock::blockFor):
        (JSC::MarkedBlock::vm const):
        (JSC::MarkedBlock::weakSet):
        (JSC::MarkedBlock::cellSize):
        (JSC::MarkedBlock::attributes const):
        (JSC::MarkedBlock::atomNumber):
        (JSC::MarkedBlock::areMarksStale):
        (JSC::MarkedBlock::aboutToMark):
        (JSC::MarkedBlock::isMarkedRaw):
        (JSC::MarkedBlock::isMarked):
        (JSC::MarkedBlock::testAndSetMarked):
        (JSC::MarkedBlock::marks const):
        (JSC::MarkedBlock::isAtom):
        (JSC::MarkedBlock::Handle::forEachCell):
        (JSC::MarkedBlock::hasAnyMarked const):
        (JSC::MarkedBlock::noteMarked):
        (WTF::MarkedBlockHash::hash):
        (JSC::MarkedBlock::firstAtom): Deleted.
        * heap/MarkedBlockInlines.h:
        (JSC::MarkedBlock::marksConveyLivenessDuringMarking):
        (JSC::MarkedBlock::Handle::isLive):
        (JSC::MarkedBlock::Handle::specializedSweep):
        (JSC::MarkedBlock::Handle::forEachLiveCell):
        (JSC::MarkedBlock::Handle::forEachDeadCell):
        (JSC::MarkedBlock::Handle::forEachMarkedCell):
        * heap/MarkedSpace.cpp:
        * heap/MarkedSpace.h:
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter32_64.asm:
        * llint/LowLevelInterpreter64.asm:

2018-01-27  Yusuke Suzuki  <utatane.tea@gmail.com>

        DFG strength reduction fails to convert NumberToStringWithValidRadixConstant for 0 to constant '0'
        https://bugs.webkit.org/show_bug.cgi?id=182213

        Reviewed by Mark Lam.

        toStringWithRadixInternal is originally used for the slow path if the given value is larger than radix or negative.
        As a result, it does not accept 0 correctly, and produces an empty string. Since DFGStrengthReductionPhase uses
        this function, it accidentally converts NumberToStringWithValidRadixConstant(0, radix) to an empty string.
        This patch fixes toStringWithRadixInternal to accept 0. This change fixes twitch.tv's issue.

        We also add a careful cast to avoid `-INT32_MIN`. It does not produce incorrect value in x86 in practice,
        but it is UB, and a compiler may assume that the given value is never INT32_MIN and could do an incorrect optimization.

        * runtime/NumberPrototype.cpp:
        (JSC::toStringWithRadixInternal):

2018-01-26  Saam Barati  <sbarati@apple.com>

        Fix emitAllocateWithNonNullAllocator to work on arm
        https://bugs.webkit.org/show_bug.cgi?id=182187
        <rdar://problem/36906550>

        Reviewed by Filip Pizlo.

        This patch unifies the x86 and ARM paths in emitAllocateWithNonNullAllocator
        and makes it so that emitAllocateWithNonNullAllocator uses the macro scratch
        register on ARM.

        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::allocateHeapCell):
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator):

2018-01-26  Joseph Pecoraro  <pecoraro@apple.com>

        Rebaselining builtin generator tests after r227685.

        Unreviewed.

        * Scripts/tests/builtins/expected/JavaScriptCore-Builtin.Promise-Combined.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-Builtin.Promise-Separate.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-Builtin.prototype-Combined.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-Builtin.prototype-Separate.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-BuiltinConstructor-Combined.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-BuiltinConstructor-Separate.js-result:
        * Scripts/tests/builtins/expected/JavaScriptCore-InternalClashingNames-Combined.js-result:
        * Scripts/tests/builtins/expected/WebCore-AnotherGuardedInternalBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-ArbitraryConditionalGuard-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-GuardedBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-GuardedInternalBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-UnguardedBuiltin-Separate.js-result:
        * Scripts/tests/builtins/expected/WebCore-xmlCasingTest-Separate.js-result:
        It used to be that the builtins generator was minifying by default. That was an accident
        and we now only minify on Release builds. The generator tests are now getting the
        default unminified output behavior so they need to update their expectations
        for some extra whitespace.

2018-01-26  Mark Lam  <mark.lam@apple.com>

        We should only append ParserArenaDeletable pointers to ParserArena::m_deletableObjects.
        https://bugs.webkit.org/show_bug.cgi?id=182180
        <rdar://problem/36460697>

        Reviewed by Michael Saboff.

        Some parser Node subclasses extend ParserArenaDeletable via multiple inheritance,
        but not as the Node's first base class.  ParserArena::m_deletableObjects is
        expecting pointers to objects of the shape of ParserArenaDeletable.  We ensure
        this by allocating the Node subclass, and casting it to ParserArenaDeletable to
        get the correct pointer to append to ParserArena::m_deletableObjects.

        To simplify things, we introduce a JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED 
        (analogous to WTF_MAKE_FAST_ALLOCATED) for use in Node subclasses that extends
        ParserArenaDeletable.

        * parser/NodeConstructors.h:
        (JSC::ParserArenaDeletable::operator new):
        * parser/Nodes.h:
        * parser/ParserArena.h:
        (JSC::ParserArena::allocateDeletable):

2018-01-26  Joseph Pecoraro  <pecoraro@apple.com>

        JavaScriptCore builtins should be partially minified in Release builds not Debug builds
        https://bugs.webkit.org/show_bug.cgi?id=182165

        Reviewed by Keith Miller.

        * Scripts/builtins/builtins_model.py:
        (BuiltinFunction.fromString):
        Apply minifications on Release builds instead of Debug builds.
        Also eliminate leading whitespace.

2018-01-26  Filip Pizlo  <fpizlo@apple.com>

        Disable TLS-based TLCs
        https://bugs.webkit.org/show_bug.cgi?id=182175

        Reviewed by Saam Barati.

        Check for the new USE(FAST_TLS_FOR_TLC) flag instead of just ENABLE(FAST_TLS_JIT).

        * heap/BlockDirectory.cpp:
        (JSC::BlockDirectory::~BlockDirectory):
        * heap/BlockDirectory.h:
        * heap/ThreadLocalCache.cpp:
        (JSC::ThreadLocalCache::installSlow):
        (JSC::ThreadLocalCache::installData):
        * heap/ThreadLocalCache.h:
        * heap/ThreadLocalCacheInlines.h:
        (JSC::ThreadLocalCache::getImpl):
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator):
        * runtime/VM.cpp:
        (JSC::VM::~VM):
        * runtime/VM.h:

2018-01-25  Yusuke Suzuki  <utatane.tea@gmail.com>

        imported/w3c/web-platform-tests/html/semantics/scripting-1/the-script-element/module/errorhandling.html crashes
        https://bugs.webkit.org/show_bug.cgi?id=181980

        Reviewed by Ryosuke Niwa.

        We accidentally failed to propagate errored promise in instantiate and satify phase if entry.{instantiate,satisfy}
        promises are set. Since we just returned `entry`, it becomes succeeded promise even if the dependent fetch, instantiate,
        and satisfy promises are failed. This patch fixes error propagation by returning `entry.instantiate` and `entry.satisfy`
        correctly.

        * builtins/ModuleLoaderPrototype.js:
        (requestInstantiate):
        (requestSatisfy):

2018-01-25  Mark Lam  <mark.lam@apple.com>

        Gardening: fix 32-bit build after r227643.
        https://bugs.webkit.org/show_bug.cgi?id=182086

        Not reviewed.

        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitDynamicPoisonOnLoadedType):

2018-01-24  Filip Pizlo  <fpizlo@apple.com>

        DirectArguments should protect itself using dynamic poisoning and precise index masking
        https://bugs.webkit.org/show_bug.cgi?id=182086

        Reviewed by Saam Barati.
        
        This implements dynamic poisoning and precise index masking in DirectArguments, using the
        helpers from <wtf/MathExtras.h> and helpers in AssemblyHelpers and FTL::LowerDFGToB3.
        
        We use dynamic poisoning for DirectArguments since this object did not have any additional
        indirection inside it that could have been poisoned. So, we use the xor of the expected type
        and the actual type as an additional input into the pointer.
        
        We use precise index masking for bounds checks, because it's not worth doing index masking
        unless we know that precise index masking is too slow.

        * assembler/MacroAssembler.h:
        (JSC::MacroAssembler::lshiftPtr):
        (JSC::MacroAssembler::rshiftPtr):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileGetByValOnDirectArguments):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileGetByVal):
        (JSC::FTL::DFG::LowerDFGToB3::compileGetMyArgumentByVal):
        (JSC::FTL::DFG::LowerDFGToB3::preciseIndexMask64):
        (JSC::FTL::DFG::LowerDFGToB3::preciseIndexMask32):
        (JSC::FTL::DFG::LowerDFGToB3::dynamicPoison):
        (JSC::FTL::DFG::LowerDFGToB3::dynamicPoisonOnLoadedType):
        (JSC::FTL::DFG::LowerDFGToB3::dynamicPoisonOnType):
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitPreciseIndexMask32):
        (JSC::AssemblyHelpers::emitDynamicPoison):
        (JSC::AssemblyHelpers::emitDynamicPoisonOnLoadedType):
        (JSC::AssemblyHelpers::emitDynamicPoisonOnType):
        * jit/AssemblyHelpers.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emitDirectArgumentsGetByVal):
        * runtime/DirectArguments.h:
        (JSC::DirectArguments::getIndexQuickly const):
        (JSC::DirectArguments::setIndexQuickly):
        (JSC::DirectArguments::argument):
        * runtime/GenericArgumentsInlines.h:

2018-01-25  Mark Lam  <mark.lam@apple.com>

        Rename some local vars from type to typedArrayType for greater clarity.
        https://bugs.webkit.org/show_bug.cgi?id=182148
        <rdar://problem/36882310>

        Reviewed by Saam Barati.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileNewTypedArrayWithSize):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNewTypedArray):

2018-01-25  Filip Pizlo  <fpizlo@apple.com>

        JSC GC should support TLCs (thread local caches)
        https://bugs.webkit.org/show_bug.cgi?id=181559

        Reviewed by Mark Lam and Saam Barati.
        
        This is a big step towards object distancing by site origin. This patch implements TLCs, or
        thread-local caches, which allow each thread to allocate from its own free lists. It also
        means that any given thread can context-switch TLCs. This will allow us to do separate
        allocation for separate site origins. Eventually, once we reshape how MarkedBlock looks, this
        will allow us to have a hard distancing constraint between objects from different origins.
        
        In this new design, every "size class" is represented as a BlockDirectory (formerly known as
        MarkedAllocator, prior to r226822). This contains a bag of blocks allocated using some
        aligned memory allocator (which roughly represents which cage you came out of), and anyone
        using the same allocator can share those blocks - but so long as they are in that
        BlockDirectory, they will have the size and type of that directory. Previously, each
        BlockDirectory had exactly one FreeList. Now, each BlockDirectory has a double-linked-list of
        LocalAllocators, each of which has a FreeList.
        
        To decide which LocalAllocator to allocate out of, we need a ThreadLocalCache and a
        BlockDirectory. The directory gives us an offset-within-the-ThreadLocalCache, which we simply
        call the Allocator (which is just a POD type that contains a 32-bit offset). Each allocation
        starts by figuring out what Allocator it wants (often we have this information at JIT time).
        Then the allocation loads its ThreadLocalCache::Data from a fast TLS slot. Then we add the
        Allocator offset to the ThreadLocalCache::Data to get the LocalAllocator. Note that we use
        offsets as opposed to indices to make it easy to do the math on each allocation (if
        LocalAllocator had a weird size then every allocation would have to do an imul).
        
        This is a definite slow-down on GC-heavy benchmarks, but by a small margin, and only on
        unusually heavy tests. For example, boyer and splay are both 3% regressed, but the Octane
        geomean is just fine. The JetStream score regressed by 0.5% with p = 0.08 (so maybe there is
        something there, but it's not significant according to our threshold).
        
        Relanding after fixing ARM64 bug in AssemblyHelpers::emitAllocateWithNonNullAllocator(). That
        function needs to be careful to avoid using the scratch register because the FTL will call it
        in disallow-scratch-register mode.

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * b3/B3LowerToAir.cpp:
        * b3/B3PatchpointSpecial.cpp:
        (JSC::B3::PatchpointSpecial::admitsStack):
        * b3/B3StackmapSpecial.cpp:
        (JSC::B3::StackmapSpecial::forEachArgImpl):
        (JSC::B3::StackmapSpecial::isArgValidForRep):
        * b3/B3StackmapValue.cpp:
        (JSC::B3::StackmapValue::appendSomeRegisterWithClobber):
        * b3/B3StackmapValue.h:
        * b3/B3Validate.cpp:
        * b3/B3ValueRep.cpp:
        (JSC::B3::ValueRep::addUsedRegistersTo const):
        (JSC::B3::ValueRep::dump const):
        (WTF::printInternal):
        * b3/B3ValueRep.h:
        (JSC::B3::ValueRep::ValueRep):
        * bytecode/AccessCase.cpp:
        (JSC::AccessCase::generateImpl):
        * bytecode/ObjectAllocationProfile.h:
        (JSC::ObjectAllocationProfile::ObjectAllocationProfile):
        (JSC::ObjectAllocationProfile::clear):
        * bytecode/ObjectAllocationProfileInlines.h:
        (JSC::ObjectAllocationProfile::initializeProfile):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::emitAllocateRawObject):
        (JSC::DFG::SpeculativeJIT::compileMakeRope):
        (JSC::DFG::SpeculativeJIT::compileAllocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileReallocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileCreateThis):
        (JSC::DFG::SpeculativeJIT::compileNewObject):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::emitAllocateJSCell):
        (JSC::DFG::SpeculativeJIT::emitAllocateJSObject):
        * ftl/FTLAbstractHeapRepository.h:
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileMakeRope):
        (JSC::FTL::DFG::LowerDFGToB3::compileMaterializeNewObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatePropertyStorageWithSizeImpl):
        (JSC::FTL::DFG::LowerDFGToB3::allocateHeapCell):
        (JSC::FTL::DFG::LowerDFGToB3::allocateObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatorForSize):
        (JSC::FTL::DFG::LowerDFGToB3::allocateVariableSizedObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocateVariableSizedCell):
        * heap/Allocator.cpp: Added.
        (JSC::Allocator::cellSize const):
        * heap/Allocator.h: Added.
        (JSC::Allocator::Allocator):
        (JSC::Allocator::offset const):
        (JSC::Allocator::operator== const):
        (JSC::Allocator::operator!= const):
        (JSC::Allocator::operator bool const):
        * heap/AllocatorInlines.h: Added.
        (JSC::Allocator::allocate const):
        (JSC::Allocator::tryAllocate const):
        * heap/BlockDirectory.cpp:
        (JSC::BlockDirectory::BlockDirectory):
        (JSC::BlockDirectory::findBlockForAllocation):
        (JSC::BlockDirectory::stopAllocating):
        (JSC::BlockDirectory::prepareForAllocation):
        (JSC::BlockDirectory::stopAllocatingForGood):
        (JSC::BlockDirectory::resumeAllocating):
        (JSC::BlockDirectory::endMarking):
        (JSC::BlockDirectory::isFreeListedCell):
        (JSC::BlockDirectory::didConsumeFreeList): Deleted.
        (JSC::BlockDirectory::tryAllocateWithoutCollecting): Deleted.
        (JSC::BlockDirectory::allocateIn): Deleted.
        (JSC::BlockDirectory::tryAllocateIn): Deleted.
        (JSC::BlockDirectory::doTestCollectionsIfNeeded): Deleted.
        (JSC::BlockDirectory::allocateSlowCase): Deleted.
        * heap/BlockDirectory.h:
        (JSC::BlockDirectory::cellKind const):
        (JSC::BlockDirectory::allocator const):
        (JSC::BlockDirectory::freeList const): Deleted.
        (JSC::BlockDirectory::offsetOfFreeList): Deleted.
        (JSC::BlockDirectory::offsetOfCellSize): Deleted.
        * heap/BlockDirectoryInlines.h:
        (JSC::BlockDirectory::isFreeListedCell const): Deleted.
        (JSC::BlockDirectory::allocate): Deleted.
        * heap/CompleteSubspace.cpp:
        (JSC::CompleteSubspace::CompleteSubspace):
        (JSC::CompleteSubspace::allocatorFor):
        (JSC::CompleteSubspace::allocate):
        (JSC::CompleteSubspace::allocateNonVirtual):
        (JSC::CompleteSubspace::allocatorForSlow):
        (JSC::CompleteSubspace::allocateSlow):
        (JSC::CompleteSubspace::tryAllocateSlow):
        * heap/CompleteSubspace.h:
        (JSC::CompleteSubspace::allocatorForSizeStep):
        (JSC::CompleteSubspace::allocatorForNonVirtual):
        * heap/FreeList.h:
        * heap/GCDeferralContext.h:
        * heap/Heap.cpp:
        (JSC::Heap::Heap):
        (JSC::Heap::lastChanceToFinalize):
        * heap/Heap.h:
        (JSC::Heap::threadLocalCacheLayout):
        * heap/IsoCellSet.h:
        * heap/IsoSubspace.cpp:
        (JSC::IsoSubspace::IsoSubspace):
        (JSC::IsoSubspace::allocatorFor):
        (JSC::IsoSubspace::allocate):
        (JSC::IsoSubspace::allocateNonVirtual):
        * heap/IsoSubspace.h:
        (JSC::IsoSubspace::allocatorForNonVirtual):
        * heap/LocalAllocator.cpp: Added.
        (JSC::LocalAllocator::LocalAllocator):
        (JSC::LocalAllocator::reset):
        (JSC::LocalAllocator::~LocalAllocator):
        (JSC::LocalAllocator::stopAllocating):
        (JSC::LocalAllocator::resumeAllocating):
        (JSC::LocalAllocator::prepareForAllocation):
        (JSC::LocalAllocator::stopAllocatingForGood):
        (JSC::LocalAllocator::allocateSlowCase):
        (JSC::LocalAllocator::didConsumeFreeList):
        (JSC::LocalAllocator::tryAllocateWithoutCollecting):
        (JSC::LocalAllocator::allocateIn):
        (JSC::LocalAllocator::tryAllocateIn):
        (JSC::LocalAllocator::doTestCollectionsIfNeeded):
        (JSC::LocalAllocator::isFreeListedCell const):
        * heap/LocalAllocator.h: Added.
        (JSC::LocalAllocator::offsetOfFreeList):
        (JSC::LocalAllocator::offsetOfCellSize):
        * heap/LocalAllocatorInlines.h: Added.
        (JSC::LocalAllocator::allocate):
        * heap/MarkedSpace.cpp:
        (JSC::MarkedSpace::stopAllocatingForGood):
        * heap/MarkedSpace.h:
        * heap/SlotVisitor.cpp:
        * heap/SlotVisitor.h:
        * heap/Subspace.h:
        * heap/ThreadLocalCache.cpp: Added.
        (JSC::ThreadLocalCache::create):
        (JSC::ThreadLocalCache::ThreadLocalCache):
        (JSC::ThreadLocalCache::~ThreadLocalCache):
        (JSC::ThreadLocalCache::allocateData):
        (JSC::ThreadLocalCache::destroyData):
        (JSC::ThreadLocalCache::installSlow):
        (JSC::ThreadLocalCache::installData):
        (JSC::ThreadLocalCache::allocatorSlow):
        (JSC::ThreadLocalCache::destructor):
        * heap/ThreadLocalCache.h: Added.
        (JSC::ThreadLocalCache::offsetOfSize):
        (JSC::ThreadLocalCache::offsetOfFirstAllocator):
        * heap/ThreadLocalCacheInlines.h: Added.
        (JSC::ThreadLocalCache::getImpl):
        (JSC::ThreadLocalCache::get):
        (JSC::ThreadLocalCache::install):
        (JSC::ThreadLocalCache::allocator):
        (JSC::ThreadLocalCache::tryGetAllocator):
        * heap/ThreadLocalCacheLayout.cpp: Added.
        (JSC::ThreadLocalCacheLayout::ThreadLocalCacheLayout):
        (JSC::ThreadLocalCacheLayout::~ThreadLocalCacheLayout):
        (JSC::ThreadLocalCacheLayout::allocateOffset):
        (JSC::ThreadLocalCacheLayout::snapshot):
        (JSC::ThreadLocalCacheLayout::directory):
        * heap/ThreadLocalCacheLayout.h: Added.
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator):
        (JSC::AssemblyHelpers::emitAllocate):
        (JSC::AssemblyHelpers::emitAllocateVariableSized):
        * jit/AssemblyHelpers.h:
        (JSC::AssemblyHelpers::vm):
        (JSC::AssemblyHelpers::emitAllocateJSCell):
        (JSC::AssemblyHelpers::emitAllocateJSObject):
        (JSC::AssemblyHelpers::emitAllocateJSObjectWithKnownSize):
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator): Deleted.
        (JSC::AssemblyHelpers::emitAllocate): Deleted.
        (JSC::AssemblyHelpers::emitAllocateVariableSized): Deleted.
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_new_object):
        (JSC::JIT::emit_op_create_this):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emit_op_new_object):
        (JSC::JIT::emit_op_create_this):
        * runtime/ButterflyInlines.h:
        (JSC::Butterfly::createUninitialized):
        (JSC::Butterfly::tryCreate):
        (JSC::Butterfly::growArrayRight):
        * runtime/DirectArguments.cpp:
        (JSC::DirectArguments::overrideThings):
        * runtime/GenericArgumentsInlines.h:
        (JSC::GenericArguments<Type>::initModifiedArgumentsDescriptor):
        * runtime/HashMapImpl.h:
        (JSC::HashMapBuffer::create):
        * runtime/JSArray.cpp:
        (JSC::JSArray::tryCreateUninitializedRestricted):
        (JSC::JSArray::unshiftCountSlowCase):
        * runtime/JSArray.h:
        (JSC::JSArray::tryCreate):
        * runtime/JSArrayBufferView.cpp:
        (JSC::JSArrayBufferView::ConstructionContext::ConstructionContext):
        * runtime/JSCellInlines.h:
        (JSC::tryAllocateCellHelper):
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::JSGlobalObject):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::threadLocalCache const):
        * runtime/JSLock.cpp:
        (JSC::JSLock::didAcquireLock):
        * runtime/Options.h:
        * runtime/RegExpMatchesArray.h:
        (JSC::tryCreateUninitializedRegExpMatchesArray):
        * runtime/VM.cpp:
        (JSC::VM::VM):
        * runtime/VM.h:
        * runtime/VMEntryScope.cpp:
        (JSC::VMEntryScope::VMEntryScope):

2018-01-25  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r227592.
        https://bugs.webkit.org/show_bug.cgi?id=182110

        it made ARM64 (Linux and iOS) crash (Requested by pizlo-mbp on
        #webkit).

        Reverted changeset:

        "JSC GC should support TLCs (thread local caches)"
        https://bugs.webkit.org/show_bug.cgi?id=181559
        https://trac.webkit.org/changeset/227592

2018-01-25  Alejandro G. Castro  <alex@igalia.com>

        undefined reference to 'JSC::B3::BasicBlock::fallThrough() const
        https://bugs.webkit.org/show_bug.cgi?id=180637

        Reviewed by Michael Catanzaro.

        We need to make sure the implementation of the inline functions is
        compiled when we compile the code using the function, now that the
        compilation is divided, or we could end up with undefined symbols
        when the declaration is not inlined, at least with some compilers
        and optimizations enabled -O2.

        * b3/B3SwitchValue.cpp: replace the include.

2018-01-20  Filip Pizlo  <fpizlo@apple.com>

        JSC GC should support TLCs (thread local caches)
        https://bugs.webkit.org/show_bug.cgi?id=181559

        Reviewed by Mark Lam and Saam Barati.
        
        This is a big step towards object distancing by site origin. This patch implements TLCs, or
        thread-local caches, which allow each thread to allocate from its own free lists. It also
        means that any given thread can context-switch TLCs. This will allow us to do separate
        allocation for separate site origins. Eventually, once we reshape how MarkedBlock looks, this
        will allow us to have a hard distancing constraint between objects from different origins.
        
        In this new design, every "size class" is represented as a BlockDirectory (formerly known as
        MarkedAllocator, prior to r226822). This contains a bag of blocks allocated using some
        aligned memory allocator (which roughly represents which cage you came out of), and anyone
        using the same allocator can share those blocks - but so long as they are in that
        BlockDirectory, they will have the size and type of that directory. Previously, each
        BlockDirectory had exactly one FreeList. Now, each BlockDirectory has a double-linked-list of
        LocalAllocators, each of which has a FreeList.
        
        To decide which LocalAllocator to allocate out of, we need a ThreadLocalCache and a
        BlockDirectory. The directory gives us an offset-within-the-ThreadLocalCache, which we simply
        call the Allocator (which is just a POD type that contains a 32-bit offset). Each allocation
        starts by figuring out what Allocator it wants (often we have this information at JIT time).
        Then the allocation loads its ThreadLocalCache::Data from a fast TLS slot. Then we add the
        Allocator offset to the ThreadLocalCache::Data to get the LocalAllocator. Note that we use
        offsets as opposed to indices to make it easy to do the math on each allocation (if
        LocalAllocator had a weird size then every allocation would have to do an imul).
        
        This is a definite slow-down on GC-heavy benchmarks, but by a small margin, and only on
        unusually heavy tests. For example, boyer and splay are both 3% regressed, but the Octane
        geomean is just fine. The JetStream score regressed by 0.5% with p = 0.08 (so maybe there is
        something there, but it's not significant according to our threshold).

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * b3/B3LowerToAir.cpp:
        * b3/B3PatchpointSpecial.cpp:
        (JSC::B3::PatchpointSpecial::admitsStack):
        * b3/B3StackmapSpecial.cpp:
        (JSC::B3::StackmapSpecial::forEachArgImpl):
        (JSC::B3::StackmapSpecial::isArgValidForRep):
        * b3/B3StackmapValue.cpp:
        (JSC::B3::StackmapValue::appendSomeRegisterWithClobber):
        * b3/B3StackmapValue.h:
        * b3/B3Validate.cpp:
        * b3/B3ValueRep.cpp:
        (JSC::B3::ValueRep::addUsedRegistersTo const):
        (JSC::B3::ValueRep::dump const):
        (WTF::printInternal):
        * b3/B3ValueRep.h:
        (JSC::B3::ValueRep::ValueRep):
        * bytecode/AccessCase.cpp:
        (JSC::AccessCase::generateImpl):
        * bytecode/ObjectAllocationProfile.h:
        (JSC::ObjectAllocationProfile::ObjectAllocationProfile):
        (JSC::ObjectAllocationProfile::clear):
        * bytecode/ObjectAllocationProfileInlines.h:
        (JSC::ObjectAllocationProfile::initializeProfile):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::emitAllocateRawObject):
        (JSC::DFG::SpeculativeJIT::compileMakeRope):
        (JSC::DFG::SpeculativeJIT::compileAllocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileReallocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileCreateThis):
        (JSC::DFG::SpeculativeJIT::compileNewObject):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::emitAllocateJSCell):
        (JSC::DFG::SpeculativeJIT::emitAllocateJSObject):
        * ftl/FTLAbstractHeapRepository.h:
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileMakeRope):
        (JSC::FTL::DFG::LowerDFGToB3::compileMaterializeNewObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatePropertyStorageWithSizeImpl):
        (JSC::FTL::DFG::LowerDFGToB3::allocateHeapCell):
        (JSC::FTL::DFG::LowerDFGToB3::allocateObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatorForSize):
        (JSC::FTL::DFG::LowerDFGToB3::allocateVariableSizedObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocateVariableSizedCell):
        * heap/Allocator.cpp: Added.
        (JSC::Allocator::cellSize const):
        * heap/Allocator.h: Added.
        (JSC::Allocator::Allocator):
        (JSC::Allocator::offset const):
        (JSC::Allocator::operator== const):
        (JSC::Allocator::operator!= const):
        (JSC::Allocator::operator bool const):
        * heap/AllocatorInlines.h: Added.
        (JSC::Allocator::allocate const):
        (JSC::Allocator::tryAllocate const):
        * heap/BlockDirectory.cpp:
        (JSC::BlockDirectory::BlockDirectory):
        (JSC::BlockDirectory::findBlockForAllocation):
        (JSC::BlockDirectory::stopAllocating):
        (JSC::BlockDirectory::prepareForAllocation):
        (JSC::BlockDirectory::stopAllocatingForGood):
        (JSC::BlockDirectory::resumeAllocating):
        (JSC::BlockDirectory::endMarking):
        (JSC::BlockDirectory::isFreeListedCell):
        (JSC::BlockDirectory::didConsumeFreeList): Deleted.
        (JSC::BlockDirectory::tryAllocateWithoutCollecting): Deleted.
        (JSC::BlockDirectory::allocateIn): Deleted.
        (JSC::BlockDirectory::tryAllocateIn): Deleted.
        (JSC::BlockDirectory::doTestCollectionsIfNeeded): Deleted.
        (JSC::BlockDirectory::allocateSlowCase): Deleted.
        * heap/BlockDirectory.h:
        (JSC::BlockDirectory::cellKind const):
        (JSC::BlockDirectory::allocator const):
        (JSC::BlockDirectory::freeList const): Deleted.
        (JSC::BlockDirectory::offsetOfFreeList): Deleted.
        (JSC::BlockDirectory::offsetOfCellSize): Deleted.
        * heap/BlockDirectoryInlines.h:
        (JSC::BlockDirectory::isFreeListedCell const): Deleted.
        (JSC::BlockDirectory::allocate): Deleted.
        * heap/CompleteSubspace.cpp:
        (JSC::CompleteSubspace::CompleteSubspace):
        (JSC::CompleteSubspace::allocatorFor):
        (JSC::CompleteSubspace::allocate):
        (JSC::CompleteSubspace::allocateNonVirtual):
        (JSC::CompleteSubspace::allocatorForSlow):
        (JSC::CompleteSubspace::allocateSlow):
        (JSC::CompleteSubspace::tryAllocateSlow):
        * heap/CompleteSubspace.h:
        (JSC::CompleteSubspace::allocatorForSizeStep):
        (JSC::CompleteSubspace::allocatorForNonVirtual):
        * heap/FreeList.h:
        * heap/GCDeferralContext.h:
        * heap/Heap.cpp:
        (JSC::Heap::Heap):
        (JSC::Heap::lastChanceToFinalize):
        * heap/Heap.h:
        (JSC::Heap::threadLocalCacheLayout):
        * heap/IsoCellSet.h:
        * heap/IsoSubspace.cpp:
        (JSC::IsoSubspace::IsoSubspace):
        (JSC::IsoSubspace::allocatorFor):
        (JSC::IsoSubspace::allocate):
        (JSC::IsoSubspace::allocateNonVirtual):
        * heap/IsoSubspace.h:
        (JSC::IsoSubspace::allocatorForNonVirtual):
        * heap/LocalAllocator.cpp: Added.
        (JSC::LocalAllocator::LocalAllocator):
        (JSC::LocalAllocator::reset):
        (JSC::LocalAllocator::~LocalAllocator):
        (JSC::LocalAllocator::stopAllocating):
        (JSC::LocalAllocator::resumeAllocating):
        (JSC::LocalAllocator::prepareForAllocation):
        (JSC::LocalAllocator::stopAllocatingForGood):
        (JSC::LocalAllocator::allocateSlowCase):
        (JSC::LocalAllocator::didConsumeFreeList):
        (JSC::LocalAllocator::tryAllocateWithoutCollecting):
        (JSC::LocalAllocator::allocateIn):
        (JSC::LocalAllocator::tryAllocateIn):
        (JSC::LocalAllocator::doTestCollectionsIfNeeded):
        (JSC::LocalAllocator::isFreeListedCell const):
        * heap/LocalAllocator.h: Added.
        (JSC::LocalAllocator::offsetOfFreeList):
        (JSC::LocalAllocator::offsetOfCellSize):
        * heap/LocalAllocatorInlines.h: Added.
        (JSC::LocalAllocator::allocate):
        * heap/MarkedSpace.cpp:
        (JSC::MarkedSpace::stopAllocatingForGood):
        * heap/MarkedSpace.h:
        * heap/SlotVisitor.cpp:
        * heap/SlotVisitor.h:
        * heap/Subspace.h:
        * heap/ThreadLocalCache.cpp: Added.
        (JSC::ThreadLocalCache::create):
        (JSC::ThreadLocalCache::ThreadLocalCache):
        (JSC::ThreadLocalCache::~ThreadLocalCache):
        (JSC::ThreadLocalCache::allocateData):
        (JSC::ThreadLocalCache::destroyData):
        (JSC::ThreadLocalCache::installSlow):
        (JSC::ThreadLocalCache::installData):
        (JSC::ThreadLocalCache::allocatorSlow):
        (JSC::ThreadLocalCache::destructor):
        * heap/ThreadLocalCache.h: Added.
        (JSC::ThreadLocalCache::offsetOfSize):
        (JSC::ThreadLocalCache::offsetOfFirstAllocator):
        * heap/ThreadLocalCacheInlines.h: Added.
        (JSC::ThreadLocalCache::getImpl):
        (JSC::ThreadLocalCache::get):
        (JSC::ThreadLocalCache::install):
        (JSC::ThreadLocalCache::allocator):
        (JSC::ThreadLocalCache::tryGetAllocator):
        * heap/ThreadLocalCacheLayout.cpp: Added.
        (JSC::ThreadLocalCacheLayout::ThreadLocalCacheLayout):
        (JSC::ThreadLocalCacheLayout::~ThreadLocalCacheLayout):
        (JSC::ThreadLocalCacheLayout::allocateOffset):
        (JSC::ThreadLocalCacheLayout::snapshot):
        (JSC::ThreadLocalCacheLayout::directory):
        * heap/ThreadLocalCacheLayout.h: Added.
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator):
        (JSC::AssemblyHelpers::emitAllocate):
        (JSC::AssemblyHelpers::emitAllocateVariableSized):
        * jit/AssemblyHelpers.h:
        (JSC::AssemblyHelpers::vm):
        (JSC::AssemblyHelpers::emitAllocateJSCell):
        (JSC::AssemblyHelpers::emitAllocateJSObject):
        (JSC::AssemblyHelpers::emitAllocateJSObjectWithKnownSize):
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator): Deleted.
        (JSC::AssemblyHelpers::emitAllocate): Deleted.
        (JSC::AssemblyHelpers::emitAllocateVariableSized): Deleted.
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_new_object):
        (JSC::JIT::emit_op_create_this):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emit_op_new_object):
        (JSC::JIT::emit_op_create_this):
        * runtime/ButterflyInlines.h:
        (JSC::Butterfly::createUninitialized):
        (JSC::Butterfly::tryCreate):
        (JSC::Butterfly::growArrayRight):
        * runtime/DirectArguments.cpp:
        (JSC::DirectArguments::overrideThings):
        * runtime/GenericArgumentsInlines.h:
        (JSC::GenericArguments<Type>::initModifiedArgumentsDescriptor):
        * runtime/HashMapImpl.h:
        (JSC::HashMapBuffer::create):
        * runtime/JSArray.cpp:
        (JSC::JSArray::tryCreateUninitializedRestricted):
        (JSC::JSArray::unshiftCountSlowCase):
        * runtime/JSArray.h:
        (JSC::JSArray::tryCreate):
        * runtime/JSArrayBufferView.cpp:
        (JSC::JSArrayBufferView::ConstructionContext::ConstructionContext):
        * runtime/JSCellInlines.h:
        (JSC::tryAllocateCellHelper):
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::JSGlobalObject):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::threadLocalCache const):
        * runtime/JSLock.cpp:
        (JSC::JSLock::didAcquireLock):
        * runtime/Options.h:
        * runtime/RegExpMatchesArray.h:
        (JSC::tryCreateUninitializedRegExpMatchesArray):
        * runtime/VM.cpp:
        (JSC::VM::VM):
        * runtime/VM.h:
        * runtime/VMEntryScope.cpp:
        (JSC::VMEntryScope::VMEntryScope):

2018-01-24  Joseph Pecoraro  <pecoraro@apple.com>

        Web Inspector: Simplify update-LegacyInspectorBackendCommands.rb
        https://bugs.webkit.org/show_bug.cgi?id=182067

        Reviewed by Brian Burg.

        * inspector/scripts/codegen/models.py:
        (Framework.fromString):
        (Frameworks):
        * inspector/scripts/generate-inspector-protocol-bindings.py:
        (generate_from_specification):
        Allow framework WebInspectorUI to generate just the backend commands files.

2018-01-23  Mark Lam  <mark.lam@apple.com>

        Update Poisoned pointers to take a Poison class instead of a uintptr_t&.
        https://bugs.webkit.org/show_bug.cgi?id=182017
        <rdar://problem/36795513>

        Reviewed by Filip Pizlo and JF Bastien.

        Removed the POISON() macro.  Now that we have Poison types, we can just use the
        the Poison type instead and make the code a bit nicer to read.

        * API/JSAPIWrapperObject.h:
        * API/JSCallbackFunction.h:
        * API/JSCallbackObject.h:
        * b3/B3LowerMacros.cpp:
        * b3/testb3.cpp:
        (JSC::B3::testInterpreter):
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::instructions):
        (JSC::CodeBlock::instructions const):
        * dfg/DFGOSRExitCompilerCommon.h:
        (JSC::DFG::adjustFrameAndStackInOSRExitCompilerThunk):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileCheckSubClass):
        (JSC::DFG::SpeculativeJIT::emitSwitchIntJump):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileCheckSubClass):
        * jit/JIT.h:
        * jit/ThunkGenerators.cpp:
        (JSC::virtualThunkFor):
        (JSC::nativeForGenerator):
        (JSC::boundThisNoArgsFunctionCallGenerator):
        * parser/UnlinkedSourceCode.h:
        * runtime/ArrayPrototype.h:
        * runtime/CustomGetterSetter.h:
        * runtime/DateInstance.h:
        * runtime/InternalFunction.h:
        * runtime/JSArrayBuffer.h:
        * runtime/JSCPoison.cpp:
        (JSC::initializePoison):
        * runtime/JSCPoison.h:
        * runtime/JSGlobalObject.h:
        * runtime/JSScriptFetchParameters.h:
        * runtime/JSScriptFetcher.h:
        * runtime/NativeExecutable.h:
        * runtime/StructureTransitionTable.h:
        * runtime/WriteBarrier.h:
        (JSC::WriteBarrier::poison): Deleted.
        * wasm/js/JSToWasm.cpp:
        (JSC::Wasm::createJSToWasmWrapper):
        * wasm/js/JSWebAssemblyCodeBlock.cpp:
        (JSC::JSWebAssemblyCodeBlock::JSWebAssemblyCodeBlock):
        * wasm/js/JSWebAssemblyCodeBlock.h:
        * wasm/js/JSWebAssemblyInstance.h:
        (JSC::JSWebAssemblyInstance::poison):
        * wasm/js/JSWebAssemblyMemory.h:
        * wasm/js/JSWebAssemblyModule.h:
        * wasm/js/JSWebAssemblyTable.h:
        * wasm/js/WasmToJS.cpp:
        (JSC::Wasm::handleBadI64Use):
        (JSC::Wasm::wasmToJS):
        * wasm/js/WebAssemblyFunctionBase.h:
        * wasm/js/WebAssemblyModuleRecord.h:
        * wasm/js/WebAssemblyToJSCallee.h:
        * wasm/js/WebAssemblyWrapperFunction.h:

2018-01-23  Yusuke Suzuki  <utatane.tea@gmail.com>

        Unreviewed, suppress GCC warnings
        https://bugs.webkit.org/show_bug.cgi?id=181976

        * runtime/TypedArrayType.h:

2018-01-23  Yusuke Suzuki  <utatane.tea@gmail.com>

        [YARR] Add diagnosis for YarrJIT failures
        https://bugs.webkit.org/show_bug.cgi?id=181927

        Reviewed by Sam Weinig.

        It is nice if we can see the reason why YarrJIT fails to compile a given pattern.
        This patch introduces Yarr::JITFailureReason and dumps messages if Options::dumpCompiledRegExpPatterns is specified.

        * runtime/RegExp.cpp:
        (JSC::RegExp::compile):
        (JSC::RegExp::compileMatchOnly):
        * yarr/YarrJIT.cpp:
        (JSC::Yarr::YarrGenerator::generateTerm):
        (JSC::Yarr::YarrGenerator::backtrackTerm):
        (JSC::Yarr::YarrGenerator::opCompileParenthesesSubpattern):
        (JSC::Yarr::YarrGenerator::YarrGenerator):
        (JSC::Yarr::YarrGenerator::compile):
        (JSC::Yarr::dumpCompileFailure):
        (JSC::Yarr::jitCompile):
        * yarr/YarrJIT.h:
        (JSC::Yarr::YarrCodeBlock::setFallBack):
        (JSC::Yarr::YarrCodeBlock::fallBack):
        (JSC::Yarr::YarrCodeBlock::clear):
        (JSC::Yarr::YarrCodeBlock::YarrCodeBlock): Deleted.
        (JSC::Yarr::YarrCodeBlock::~YarrCodeBlock): Deleted.
        (JSC::Yarr::YarrCodeBlock::isFallBack): Deleted.

2018-01-23  Alex Christensen  <achristensen@webkit.org>

        Remove pre-Sierra-OS-specific code in WTF and JavaScriptCore
        https://bugs.webkit.org/show_bug.cgi?id=182028

        Reviewed by Keith Miller.

        * inspector/remote/cocoa/RemoteInspectorXPCConnection.h:
        * inspector/remote/cocoa/RemoteInspectorXPCConnection.mm:
        (Inspector::RemoteInspectorXPCConnection::handleEvent):

2018-01-23  Filip Pizlo  <fpizlo@apple.com>

        Use precise index masking for FTL GetByArgumentByVal
        https://bugs.webkit.org/show_bug.cgi?id=182006

        Reviewed by Keith Miller.
        
        This protects speculative out-of-bounds on arguments[index].
        
        Making this work right involved fixing a possible overflow situation with
        numberOfArgumentsToSkip.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::findArgumentPositionForLocal):
        * dfg/DFGGraph.cpp:
        (JSC::DFG::Graph::dump):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::hasNumberOfArgumentsToSkip):
        (JSC::DFG::Node::numberOfArgumentsToSkip):
        * dfg/DFGStackLayoutPhase.cpp:
        (JSC::DFG::StackLayoutPhase::run):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileGetMyArgumentByVal):

2018-01-23  David Kilzer  <ddkilzer@apple.com>

        Follow-up for: oss-fuzz jsc build is broken: StringImpl.h:27:10: fatal error: 'unicode/ustring.h' file not found
        <https://webkit.org/b/181871>
        <rdar://problem/36669691>

        Address feedback for this change.

        * CMakeLists.txt: Change "SYSTEM PUBLIC" to "SYSTEM PRIVATE" per
        feedback from Konstantin Tokarev.

2018-01-23  Robin Morisset  <rmorisset@apple.com>

        Rollout r219636
        https://bugs.webkit.org/show_bug.cgi?id=181997
        <rdar://problem/35883022>

        Unreviewed, as it is a rollout.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::emitAllocateRawObject):
        * runtime/JSArray.cpp:
        (JSC::JSArray::tryCreateUninitializedRestricted):
        * runtime/JSArray.h:
        (JSC::JSArray::tryCreate):
        * runtime/JSObject.cpp:
        (JSC::JSObject::ensureLengthSlow):

2018-01-23  Mark Lam  <mark.lam@apple.com>

        Re-arrange TypedArray JSTypes to match the order of the TypedArrayType enum list.
        https://bugs.webkit.org/show_bug.cgi?id=181976
        <rdar://problem/36766936>

        Reviewed by Filip Pizlo.

        1. The order of TypedArray JSTypes now matches the order the TypedArrayType enum
           list.  I also added static asserts in TypedArrayType.h to enforce this.

           Also redefined FOR_EACH_TYPED_ARRAY_TYPE() in terms of

        2. Define 4 new values:
           a. FirstTypedArrayType
           b. LastTypedArrayType
           c. NumberOfTypedArrayTypesExcludingDataView
           d. NumberOfTypedArrayTypes

           Use these everywhere where we iterate or bisect the TypedArray JSTypes.

        3. Removed NUMBER_OF_TYPED_ARRAY_TYPES, and use NumberOfTypedArrayTypes instead.

        4. Simplify the code that converts between TypedArrayType and JSType.

           Changed typedArrayTypeForType() to be the mirror image of typeForTypedArrayType().
           Previously, typedArrayTypeForType() converts DataViewType to NotTypedArray
           instead of TypeDataView.  Now, it converts to TypeDataView.

           This does not result in any change of behavior because typedArrayTypeForType()
           is only called in Structure::hasIndexingHeader(), and its result is passed to
           isTypedView(), which handles TypeDataView correctly.

        5. Also fixed a bug in SpeculativeJIT::compileGetTypedArrayByteOffset().
           If the vector is null, we can skip the rest of the checks.  While the current
           code does not result in incorrect behavior, it is inefficient, and communicates
           wrong information to the reader i.e. implying that there's something in the
           dataGPR when there's not.  The dataGPR should also be null in this case.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleConstantInternalFunction):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileIsTypedArrayView):
        (JSC::DFG::SpeculativeJIT::compileGetTypedArrayByteOffset):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::isTypedArrayView):
        * ftl/FTLOSRExit.cpp:
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter64.asm:
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::visitChildren):
        * runtime/JSType.h:
        * runtime/TypedArrayType.cpp:
        (JSC::typeForTypedArrayType): Deleted.
        * runtime/TypedArrayType.h:
        (JSC::typedArrayTypeForType):
        (JSC::typeForTypedArrayType):

2018-01-23  Filip Pizlo  <fpizlo@apple.com>

        DFG should always flush `this`
        https://bugs.webkit.org/show_bug.cgi?id=181999

        Reviewed by Saam Barati and Mark Lam.
        
        This is going to make it possible to use precise index masking for arguments-on-the-stack
        accesses with an index adjusted so that 0 is this. Without this change, we would have no way
        of masking when the argument count is 0, unless we padded the argument area so that there was
        always an argument slot after `this` and it was always initialized.
        
        This is neutral on all benchmarks.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::flushImpl):
        (JSC::DFG::ByteCodeParser::flushForTerminalImpl):
        (JSC::DFG::ByteCodeParser::flush):
        (JSC::DFG::ByteCodeParser::flushForTerminal):
        (JSC::DFG::ByteCodeParser::parse):
        (JSC::DFG::flushImpl): Deleted.
        (JSC::DFG::flushForTerminalImpl): Deleted.
        * dfg/DFGPreciseLocalClobberize.h:
        (JSC::DFG::PreciseLocalClobberizeAdaptor::readTop):

2018-01-23  Filip Pizlo  <fpizlo@apple.com>

        JSC should use a speculation fence on VM entry/exit
        https://bugs.webkit.org/show_bug.cgi?id=181991

        Reviewed by JF Bastien and Mark Lam.
        
        This adds a WTF::speculationFence on VM entry and exit.
        
        For a microbenchmark that just calls a native function (supplied via an Objective-C block) in a
        tight loop from JS is a 0% regression on x86 and a 11% regression on ARM64.
        
        * runtime/JSLock.cpp:
        (JSC::JSLock::didAcquireLock):
        (JSC::JSLock::willReleaseLock):

2018-01-23  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] JIT requires sizeof(bool) == 1
        https://bugs.webkit.org/show_bug.cgi?id=181150

        Reviewed by Saam Barati.

        LLInt and JIT assumes that sizeof(bool) == 1. But it is implementation-dependent in C++ spec.
        Since this is a mandatory requirement in JSC, we add a static_assert to ensure this.

        * runtime/InitializeThreading.cpp:

2018-01-23  Robin Morisset  <rmorisset@apple.com>

        Update the argument count in DFGByteCodeParser::handleRecursiveCall
        https://bugs.webkit.org/show_bug.cgi?id=181739
        <rdar://problem/36627662>

        Reviewed by Saam Barati.

        When calling a function, its number of arguments is set on the stack. When we turn a recursive tail call
        into a jump, we should update that stack slot as there is no guarantee that the function was originally
        called with the same number of arguments. Forgetting to do this is observable through 'arguments.length'.

        It required adding a new DFG node: 'SetArgumentCountIncludingThis', that takes an unsigned int
        as its first OpInfo field, and stores it to the stack at the right place.

        We must be a bit careful in where we put this new node, as it ClobbersExit.
        We must also fix DFGArgumentsEliminationPhase and DFGPutStackSinkingPhase as they assumed that any node that writes to the stack must write to either an argument or a local.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGArgumentsEliminationPhase.cpp:
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleRecursiveTailCall):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGMayExit.cpp:
        * dfg/DFGNode.h:
        (JSC::DFG::Node::argumentCountIncludingThis):
        * dfg/DFGNodeType.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGPutStackSinkingPhase.cpp:
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileSetArgumentCountIncludingThis):
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileSetArgumentCountIncludingThis):

2018-01-22  Michael Saboff  <msaboff@apple.com>

        DFG abstract interpreter needs to properly model effects of some Math ops
        https://bugs.webkit.org/show_bug.cgi?id=181886

        Reviewed by Saam Barati.

        Reviewed the processing of the various ArithXXX and CompareXXX and found that
        several nodes don't handle UntypedUse.  Added clobberWorld() for those cases.

        * dfg/DFGAbstractInterpreter.h:
        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeDoubleUnaryOpEffects):

2018-01-21  Wenson Hsieh  <wenson_hsieh@apple.com>

        Add a new feature flag for EXTRA_ZOOM_MODE and reintroduce AdditionalFeatureDefines.h
        https://bugs.webkit.org/show_bug.cgi?id=181918

        Reviewed by Tim Horton.

        Add EXTRA_ZOOM_MODE to FeatureDefines.xconfig (off by default).

        * Configurations/FeatureDefines.xcconfig:

2018-01-20  Caio Lima  <ticaiolima@gmail.com>

        [JSC] NumberPrototype::extractRadixFromArgs incorrectly cast double to int32_t
        https://bugs.webkit.org/show_bug.cgi?id=181182

        Reviewed by Darin Adler.

        Casting double to integer is undefined behavior when the truncation
        results into a value that doesn't fit into integer size,
        according C++ spec[1]. Thus, we are changing bigIntProtoFuncToString and
        numberProtoFuncToString to remove these source of undefined
        behavior.

        [1] - http://en.cppreference.com/w/cpp/language/implicit_conversion

        * runtime/BigIntPrototype.cpp:
        (JSC::bigIntProtoFuncToString):
        * runtime/NumberPrototype.cpp:
        (JSC::numberProtoFuncToString):
        (JSC::extractToStringRadixArgument):
        (JSC::extractRadixFromArgs): Deleted.
        * runtime/NumberPrototype.h:

2018-01-19  Saam Barati  <sbarati@apple.com>

        Kill ArithNegate's ArithProfile assert inside BytecodeParser
        https://bugs.webkit.org/show_bug.cgi?id=181877
        <rdar://problem/36630552>

        Reviewed by Mark Lam.

        Before this patch, we used to assert that op_negate's result ArithProfile
        only produces number. It's logically true that negate only produces a number.
        However, the DFG may incorrectly pick this ArithProfile when doing OSR exit
        profiling. So we'll end up profiling something that's likely the input to
        negate. This patch removes the assert. We cede to the fact that Graph::methodOfGettingAValueProfileFor
        is entirely heuristic based, potentially leading to profiling results being imprecise.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::makeSafe):

2018-01-19  David Kilzer  <ddkilzer@apple.com>

        oss-fuzz jsc build is broken: StringImpl.h:27:10: fatal error: 'unicode/ustring.h' file not found
        <https://webkit.org/b/181871>

        Rubber-stamped by JF Bastien.

        * CMakeLists.txt: Add ICU header search path to
        LLIntOffsetsExtractor target by reusing
        JavaScriptCore_SYSTEM_INCLUDE_DIRECTORIES.

2018-01-19  Saam Barati  <sbarati@apple.com>

        Spread's effects are modeled incorrectly both in AI and in Clobberize
        https://bugs.webkit.org/show_bug.cgi?id=181867
        <rdar://problem/36290415>

        Reviewed by Michael Saboff.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):

2018-01-19  Keith Miller  <keith_miller@apple.com>

        HaveInternalSDK includes should be "#include?"
        https://bugs.webkit.org/show_bug.cgi?id=179670

        Reviewed by Dan Bernstein.

        * Configurations/Base.xcconfig:

2018-01-18  JF Bastien  <jfbastien@apple.com>

        Set the minimum executable allocator size properly
        https://bugs.webkit.org/show_bug.cgi?id=181816
        <rdar://problem/36635533>

        Reviewed by Saam Barati.

        Executable allocator expects at least two page size's worth of
        allocation in certain conditions, and that causes some tests to
        now fail because they ask for less. Set that minimum correctly. We
        were already rounding up to a page size, so having a minimum of 2
        page sizes is fine.

        * jit/ExecutableAllocator.cpp:
        (JSC::FixedVMPoolExecutableAllocator::FixedVMPoolExecutableAllocator):

2018-01-18  Michael Saboff  <msaboff@apple.com>

        Unreviewed build fix for Windows

        * interpreter/FrameTracers.h:
        (JSC::assertStackPointerIsAligned): Can't use gcc style inlined assembly
        on Windows.

2018-01-18  Mark Lam  <mark.lam@apple.com>

        Poisons should be initialized after Options are initialized.
        https://bugs.webkit.org/show_bug.cgi?id=181807
        <rdar://problem/36629138>

        Reviewed by Keith Miller.

        This is because poison initialization may depend on options.

        * runtime/InitializeThreading.cpp:
        (JSC::initializeThreading):

2018-01-18  Dan Bernstein  <mitz@apple.com>

        [Xcode] Streamline and future-proof target-macOS-version-dependent build setting definitions
        https://bugs.webkit.org/show_bug.cgi?id=181803

        Reviewed by Tim Horton.

        * Configurations/Base.xcconfig: Updated.
        * Configurations/DebugRelease.xcconfig: Ditto.
        * Configurations/FeatureDefines.xcconfig: Adopted macOSTargetConditionals helpers.
        * Configurations/Version.xcconfig: Updated.
        * Configurations/macOSTargetConditionals.xcconfig: Added. Defines helper build settings
          useful for defining settings that depend on the target macOS version.

2018-01-18  Michael Saboff  <msaboff@apple.com>

        REGRESSION (r226068): [X86] Crash in JavaScriptCore ShadowChicken when handling exceptions
        https://bugs.webkit.org/show_bug.cgi?id=181802

        Reviewed by Filip Pizlo.

        There where a few places where the stack isn't properly aligned for X86 when we call into C++ code.
        Two places are where we call into exception handling code, the LLInt and from nativeForGenerator.
        The other place was when we call into the operationOSRWriteBarrier().

        Added an assert check that the stack is aligned on X86 platforms in the native call tracing code.
        This helped find the other cases beyond the original problem.

        * dfg/DFGOSRExitCompilerCommon.cpp:
        (JSC::DFG::osrWriteBarrier):
        * interpreter/FrameTracers.h:
        (JSC::assertStackPointerIsAligned):
        (JSC::NativeCallFrameTracer::NativeCallFrameTracer):
        (JSC::NativeCallFrameTracerWithRestore::NativeCallFrameTracerWithRestore):
        * jit/ThunkGenerators.cpp:
        (JSC::nativeForGenerator):
        * llint/LowLevelInterpreter32_64.asm:

2018-01-18  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r227096.
        https://bugs.webkit.org/show_bug.cgi?id=181788

        "it caused a 15% octane regression" (Requested by saamyjoon on
        #webkit).

        Reverted changeset:

        "Support MultiGetByOffset in the DFG"
        https://bugs.webkit.org/show_bug.cgi?id=181466
        https://trac.webkit.org/changeset/227096

2018-01-17  Yusuke Suzuki  <utatane.tea@gmail.com>

        [DFG][FTL] Introduce PhantomNewRegexp and RegExpExecNonGlobalOrSticky
        https://bugs.webkit.org/show_bug.cgi?id=181535

        Reviewed by Saam Barati.

        When executing the code like `string.match(/regexp/)`, `/regexp/` object is created every time we execute this code.
        However, user rarely cares about this `/regexp/` object. Typically, it is soon discarded even if it has `lastIndex`
        information. So we should not create RegExpObject for this typical case.

        This patch introduces PhantomNewRegexp. We convert NewRegexp node to PhantomNewRegexp in Object Allocation Sinking (OAS)
        phase. We should do this analysis in OAS phase since we track modifications to `lastIndex` in the OAS phase. Even if
        `lastIndex` is modified, it may not be read by users. So we have a chance to drop this NewRegexp beacause we carefully model
        SetRegExpObjectLastIndex and GetRegExpObjectLastIndex in OAS phase.

        This patch is a first attempt to drop NewRegexp. So we start optimizing it with the simple step: we first drop RegExp with
        non-global and non-sticky one. We can later extend this optimization for RegExp with global flag. But this is not included
        in this patch.

        We convert RegExpExec to RegExpExecNonGlobalOrSticky if we find that the given RegExpObject's RegExp is not global/sticky
        flagged. Since we do not need to touch `lastIndex` property in this case, RegExpExecNonGlobalOrSticky just takes RegExp
        instead of RegExpObject. This offers the chance to make NewRegExp unused.

        We also convert RegExpMatchFast to RegExpExecNonGlobalOrSticky if its RegExpObject's RegExp is non-global and non-sticky,
        since they are the same behavior.

        The above optimization completely removes NewRegexp in SixSpeed's regexp-u.{es5,es6}. The resulted execution time is
        somewhat pure execution time of our Yarr implementation.

                                     baseline                  patched

            regex-u.es5          34.8557+-0.5963     ^      6.1507+-0.5526        ^ definitely 5.6670x faster
            regex-u.es6          89.1919+-3.3851     ^     32.0917+-0.4260        ^ definitely 2.7793x faster

        This patch does not change Octane/RegExp so much since it heavily uses String.prototype.replace, which is not handled in
        this patch right now. We should support StringReplace node in subsequent patches.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::parseBlock):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGClobbersExitState.cpp:
        (JSC::DFG::clobbersExitState):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGGraph.cpp:
        (JSC::DFG::Graph::dump):
        * dfg/DFGMayExit.cpp:
        * dfg/DFGNode.cpp:
        (JSC::DFG::Node::convertToRegExpExecNonGlobalOrSticky):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::convertToPhantomNewRegexp):
        (JSC::DFG::Node::convertToSetRegExpObjectLastIndex):
        (JSC::DFG::Node::hasHeapPrediction):
        (JSC::DFG::Node::hasCellOperand):
        (JSC::DFG::Node::isPhantomAllocation):
        (JSC::DFG::Node::hasIgnoreLastIndexIsWritable):
        (JSC::DFG::Node::ignoreLastIndexIsWritable):
        * dfg/DFGNodeType.h:
        * dfg/DFGObjectAllocationSinkingPhase.cpp:
        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGPromotedHeapLocation.cpp:
        (WTF::printInternal):
        * dfg/DFGPromotedHeapLocation.h:
        (JSC::DFG::PromotedLocationDescriptor::neededForMaterialization const):
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileNewRegexp):
        (JSC::DFG::SpeculativeJIT::compileSetRegExpObjectLastIndex):
        (JSC::DFG::SpeculativeJIT::compileRegExpExecNonGlobalOrSticky):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGStrengthReductionPhase.cpp:
        (JSC::DFG::StrengthReductionPhase::handleNode):
        * dfg/DFGValidate.cpp:
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileRegExpExecNonGlobalOrSticky):
        (JSC::FTL::DFG::LowerDFGToB3::compileNewRegexp):
        (JSC::FTL::DFG::LowerDFGToB3::compileSetRegExpObjectLastIndex):
        * ftl/FTLOperations.cpp:
        (JSC::FTL::operationPopulateObjectInOSR):
        (JSC::FTL::operationMaterializeObjectInOSR):
        * jit/JITOperations.h:
        * runtime/RegExpObject.h:
        (JSC::RegExpObject::create):

2018-01-17  Yusuke Suzuki  <utatane.tea@gmail.com>

        [FTL] Remove unused helper functions to convert node to PutHint
        https://bugs.webkit.org/show_bug.cgi?id=181775

        Reviewed by Saam Barati.

        We are using PromotedHeapLocation::createHint. So they are not necessary.

        * dfg/DFGNode.cpp:
        (JSC::DFG::Node::convertToPutHint): Deleted.
        (JSC::DFG::Node::convertToPutStructureHint): Deleted.
        (JSC::DFG::Node::convertToPutByOffsetHint): Deleted.
        (JSC::DFG::Node::convertToPutClosureVarHint): Deleted.
        * dfg/DFGNode.h:

2018-01-17  Yusuke Suzuki  <utatane.tea@gmail.com>

        Unreviewed, suppress warnings on GCC

        Since `length` and `p` are always positive or zero,
        static_cast<unsigned>() does what we want.

        * runtime/JSBigInt.cpp:
        (JSC::JSBigInt::parseInt):

2018-01-17  Saam Barati  <sbarati@apple.com>

        Disable Atomics when SharedArrayBuffer isn’t enabled
        https://bugs.webkit.org/show_bug.cgi?id=181572
        <rdar://problem/36553206>

        Reviewed by Michael Saboff.

        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        (JSC::createAtomicsProperty): Deleted.

2018-01-17  Saam Barati  <sbarati@apple.com>

        Support MultiGetByOffset in the DFG
        https://bugs.webkit.org/show_bug.cgi?id=181466

        Reviewed by Keith Miller.

        This seems to benefit Speedometer in my local testing. It seems like this
        might be around a 0.5% improvement.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleGetById):
        * dfg/DFGConstantFoldingPhase.cpp:
        (JSC::DFG::ConstantFoldingPhase::foldConstants):
        * dfg/DFGGraph.h:
        (JSC::DFG::Graph::supportsMultiGetByOffset):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):

2018-01-17  Saam Barati  <sbarati@apple.com>

        DFG::Node::convertToConstant needs to clear the varargs flags
        https://bugs.webkit.org/show_bug.cgi?id=181697
        <rdar://problem/36497332>

        Reviewed by Yusuke Suzuki.

        * dfg/DFGNode.h:
        (JSC::DFG::Node::convertToConstant):

2018-01-16  JF Bastien  <jfbastien@apple.com>

        Allow dangerous disabling of poison
        https://bugs.webkit.org/show_bug.cgi?id=181685
        <rdar://problem/36546265>

        Reviewed by Keith Miller.

        Some tools such as leak detectors and such like to look at real
        pointers, and poisoned ones confuse them. Add a JSC option to
        disable poisoning, but log to the console when this is done.

        * runtime/JSCPoison.cpp:
        (JSC::initializePoison):
        * runtime/Options.h:

2018-01-16  Ryan Haddad  <ryanhaddad@apple.com>

        Unreviewed, rolling out r226937.

        Tests added with this change are failing due to a missing
        exception check.

        Reverted changeset:

        "[JSC] NumberPrototype::extractRadixFromArgs incorrectly cast
        double to int32_t"
        https://bugs.webkit.org/show_bug.cgi?id=181182
        https://trac.webkit.org/changeset/226937

2018-01-16  Michael Catanzaro  <mcatanzaro@igalia.com>

        Test programs should only be built in developer mode
        https://bugs.webkit.org/show_bug.cgi?id=181653

        Reviewed by Carlos Garcia Campos.

        Build test programs only in developer mode, and fix code style.

        * shell/CMakeLists.txt:

2018-01-15  Michael Catanzaro  <mcatanzaro@igalia.com>

        Improve use of ExportMacros
        https://bugs.webkit.org/show_bug.cgi?id=181652

        Reviewed by Konstantin Tokarev.

        * API/JSBase.h: Update a comment.
        * inspector/InspectorBackendDispatcher.h: Use a better, yet equivalent, WTF macro.
        * runtime/JSExportMacros.h: Simplify the #defines in this file.

2018-01-15  JF Bastien  <jfbastien@apple.com>

        Remove makePoisonedUnique
        https://bugs.webkit.org/show_bug.cgi?id=181630
        <rdar://problem/36498623>

        Reviewed by Mark Lam.

        I added a conversion from std::unique_ptr, so we can just use
        std::make_unique and it'll auto-poison when converted.

        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::makePoisonedUnique): Deleted.
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::makePoisonedUnique): Deleted.

2018-01-15  Michael Catanzaro  <mcatanzaro@igalia.com>

        REGRESSION(r226266): [GTK] RELEASE_ASSERT(reservedZoneSize >= minimumReservedZoneSize) in JSC::VM::updateStackLimits
        https://bugs.webkit.org/show_bug.cgi?id=181438
        <rdar://problem/36376724>

        Reviewed by Carlos Garcia Campos.

        Roll out the functional changes of r226266. We'll keep the minor CMake library type setting
        cleanup, but we have to switch back to building JSC only as a shared library, and we have to
        get rid of the version script.

        * PlatformGTK.cmake:
        * javascriptcoregtk-symbols.map: Removed.

2018-01-14  Saam Barati  <sbarati@apple.com>

        Unreviewed. r226928 broke the CLOOP build. This patch fixes the CLOOP build.

        * bytecode/CallLinkStatus.cpp:
        (JSC::CallLinkStatus::computeFromLLInt):
        (JSC::CallLinkStatus::computeExitSiteData):

2018-01-13  Mark Lam  <mark.lam@apple.com>

        Replace all use of ConstExprPoisoned with Poisoned.
        https://bugs.webkit.org/show_bug.cgi?id=181542
        <rdar://problem/36442138>

        Reviewed by JF Bastien.

        1. All JSC poisons are now defined in JSCPoison.h.

        2. Change all clients to use the new poison values via the POISON() macro.

        3. The LLInt code has been updated to handle CodeBlock poison.  Some of this code
           uses the t5 temp register, which is not available on the Windows port.
           Fortunately, we don't currently do poisoning on the Windows port yet.  So,
           it will just work for now.

           When poisoning is enabled for the Windows port, this LLInt code will need a
           Windows specific implementation to workaround its lack of a t5 register.

        * API/JSAPIWrapperObject.h:
        * API/JSCallbackFunction.h:
        * API/JSCallbackObject.h:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * assembler/MacroAssemblerCodeRef.h:
        (JSC::MacroAssemblerCodePtr::emptyValue):
        (JSC::MacroAssemblerCodePtr::deletedValue):
        * b3/B3LowerMacros.cpp:
        * b3/testb3.cpp:
        (JSC::B3::testInterpreter):
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::instructions):
        (JSC::CodeBlock::instructions const):
        (JSC::CodeBlock::makePoisonedUnique):
        * dfg/DFGOSRExitCompilerCommon.h:
        (JSC::DFG::adjustFrameAndStackInOSRExitCompilerThunk):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileCheckSubClass):
        (JSC::DFG::SpeculativeJIT::emitSwitchIntJump):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileCheckSubClass):
        * jit/JIT.h:
        * jit/ThunkGenerators.cpp:
        (JSC::virtualThunkFor):
        (JSC::nativeForGenerator):
        (JSC::boundThisNoArgsFunctionCallGenerator):
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter32_64.asm:
        * llint/LowLevelInterpreter64.asm:
        * parser/UnlinkedSourceCode.h:
        * runtime/ArrayPrototype.h:
        * runtime/CustomGetterSetter.h:
        * runtime/DateInstance.h:
        * runtime/InternalFunction.h:
        * runtime/JSArrayBuffer.h:
        * runtime/JSCPoison.cpp: Copied from Source/JavaScriptCore/runtime/JSCPoisonedPtr.cpp.
        (JSC::initializePoison):
        * runtime/JSCPoison.h:
        (): Deleted.
        * runtime/JSCPoisonedPtr.cpp: Removed.
        * runtime/JSCPoisonedPtr.h: Removed.
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::makePoisonedUnique):
        * runtime/JSScriptFetchParameters.h:
        * runtime/JSScriptFetcher.h:
        * runtime/NativeExecutable.h:
        * runtime/StructureTransitionTable.h:
        (JSC::StructureTransitionTable::map const):
        (JSC::StructureTransitionTable::weakImpl const):
        * runtime/WriteBarrier.h:
        (JSC::WriteBarrier::poison):
        * wasm/js/JSToWasm.cpp:
        (JSC::Wasm::createJSToWasmWrapper):
        * wasm/js/JSWebAssemblyCodeBlock.cpp:
        (JSC::JSWebAssemblyCodeBlock::JSWebAssemblyCodeBlock):
        * wasm/js/JSWebAssemblyCodeBlock.h:
        * wasm/js/JSWebAssemblyInstance.h:
        * wasm/js/JSWebAssemblyMemory.h:
        * wasm/js/JSWebAssemblyModule.h:
        * wasm/js/JSWebAssemblyTable.h:
        * wasm/js/WasmToJS.cpp:
        (JSC::Wasm::handleBadI64Use):
        (JSC::Wasm::wasmToJS):
        * wasm/js/WebAssemblyFunctionBase.h:
        * wasm/js/WebAssemblyModuleRecord.h:
        * wasm/js/WebAssemblyToJSCallee.h:
        * wasm/js/WebAssemblyWrapperFunction.h:

2018-01-13  Caio Lima  <ticaiolima@gmail.com>

        [JSC] NumberPrototype::extractRadixFromArgs incorrectly cast double to int32_t
        https://bugs.webkit.org/show_bug.cgi?id=181182

        Reviewed by Darin Adler.

        Casting double to integer is undefined behavior when the truncation
        results into a value that doesn't fit into integer size, according C++
        spec[1]. Thus, we are changing bigIntProtoFuncToString and
        numberProtoFuncToString to remove these source of undefined behavior.

        [1] - http://en.cppreference.com/w/cpp/language/implicit_conversion

        * runtime/BigIntPrototype.cpp:
        (JSC::bigIntProtoFuncToString):
        * runtime/NumberPrototype.cpp:
        (JSC::numberProtoFuncToString):
        (JSC::extractRadixFromArgs): Deleted.
        (JSC::extractToStringRadixArgument): Added.

2018-01-12  Saam Barati  <sbarati@apple.com>

        Move ExitProfile to UnlinkedCodeBlock so it can be shared amongst CodeBlocks backed by the same UnlinkedCodeBlock
        https://bugs.webkit.org/show_bug.cgi?id=181545

        Reviewed by Michael Saboff.

        This patch follows the theme of putting optimization profiling information on
        UnlinkedCodeBlock. This allows the unlinked code cache to remember OSR exit data.
        This often leads to the first compile of a CodeBlock, backed by an UnlinkedCodeBlock
        pulled from the code cache, making better compilation decisions, usually
        resulting in fewer exits, and fewer recompilations.
        
        This is a 1% Speedometer progression in my testing.

        * bytecode/BytecodeDumper.cpp:
        (JSC::BytecodeDumper<CodeBlock>::dumpProfilesForBytecodeOffset):
        * bytecode/CallLinkStatus.cpp:
        (JSC::CallLinkStatus::computeFromLLInt):
        (JSC::CallLinkStatus::computeFor):
        (JSC::CallLinkStatus::computeExitSiteData):
        (JSC::CallLinkStatus::computeDFGStatuses):
        * bytecode/CallLinkStatus.h:
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::addFrequentExitSite): Deleted.
        (JSC::CodeBlock::hasExitSite const): Deleted.
        (JSC::CodeBlock::exitProfile): Deleted.
        * bytecode/DFGExitProfile.cpp:
        (JSC::DFG::ExitProfile::add):
        (JSC::DFG::QueryableExitProfile::initialize):
        * bytecode/DFGExitProfile.h:
        (JSC::DFG::ExitProfile::hasExitSite const):
        * bytecode/GetByIdStatus.cpp:
        (JSC::GetByIdStatus::hasExitSite):
        (JSC::GetByIdStatus::computeFor):
        (JSC::GetByIdStatus::computeForStubInfo):
        * bytecode/GetByIdStatus.h:
        * bytecode/PutByIdStatus.cpp:
        (JSC::PutByIdStatus::hasExitSite):
        (JSC::PutByIdStatus::computeFor):
        (JSC::PutByIdStatus::computeForStubInfo):
        * bytecode/PutByIdStatus.h:
        * bytecode/UnlinkedCodeBlock.cpp:
        (JSC::UnlinkedCodeBlock::livenessAnalysisSlow):
        * bytecode/UnlinkedCodeBlock.h:
        (JSC::UnlinkedCodeBlock::hasExitSite const):
        (JSC::UnlinkedCodeBlock::hasExitSite):
        (JSC::UnlinkedCodeBlock::exitProfile):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::InlineStackEntry::InlineStackEntry):
        * dfg/DFGGraph.h:
        (JSC::DFG::Graph::hasGlobalExitSite):
        (JSC::DFG::Graph::hasExitSite):
        * dfg/DFGLICMPhase.cpp:
        (JSC::DFG::LICMPhase::attemptHoist):
        * dfg/DFGOSRExitBase.cpp:
        (JSC::DFG::OSRExitBase::considerAddingAsFrequentExitSiteSlow):

2018-01-12  JF Bastien  <jfbastien@apple.com>

        PoisonedWriteBarrier
        https://bugs.webkit.org/show_bug.cgi?id=181599
        <rdar://problem/36474351>

        Reviewed by Mark Lam.

        Allow poisoning of WriteBarrier objects, and use this for
        WebAssembly because it is perf-neutral, at least on WasmBench on
        my MBP. If it indeed is perf-neutral according to the bots, start
        using it in more performance-sensitive places.

        * heap/HandleTypes.h:
        * heap/SlotVisitor.h:
        * heap/SlotVisitorInlines.h:
        (JSC::SlotVisitor::append):
        (JSC::SlotVisitor::appendHidden):
        * runtime/JSCJSValue.h:
        * runtime/JSCPoison.h:
        * runtime/Structure.h:
        * runtime/StructureInlines.h:
        (JSC::Structure::setPrototypeWithoutTransition):
        (JSC::Structure::setGlobalObject):
        (JSC::Structure::setPreviousID):
        * runtime/WriteBarrier.h:
        (JSC::WriteBarrierBase::copyFrom):
        (JSC::WriteBarrierBase::get const):
        (JSC::WriteBarrierBase::operator* const):
        (JSC::WriteBarrierBase::operator-> const):
        (JSC::WriteBarrierBase::clear):
        (JSC::WriteBarrierBase::slot):
        (JSC::WriteBarrierBase::operator bool const):
        (JSC::WriteBarrierBase::setWithoutWriteBarrier):
        (JSC::WriteBarrierBase::unvalidatedGet const):
        (JSC::operator==):
        * runtime/WriteBarrierInlines.h:
        (JSC::Traits>::set):
        (JSC::Traits>::setMayBeNull):
        (JSC::Traits>::setEarlyValue):
        (JSC::DumbValueTraits<Unknown>>::set):
        * wasm/WasmInstance.h:
        * wasm/js/JSWebAssemblyInstance.cpp:
        (JSC::JSWebAssemblyInstance::JSWebAssemblyInstance):
        (JSC::JSWebAssemblyInstance::finishCreation):
        (JSC::JSWebAssemblyInstance::visitChildren):
        (JSC::JSWebAssemblyInstance::create):
        * wasm/js/JSWebAssemblyInstance.h:
        (JSC::JSWebAssemblyInstance::offsetOfPoisonedCallee):
        * wasm/js/JSWebAssemblyMemory.h:
        * wasm/js/JSWebAssemblyModule.h:
        * wasm/js/JSWebAssemblyTable.cpp:
        (JSC::JSWebAssemblyTable::JSWebAssemblyTable):
        (JSC::JSWebAssemblyTable::grow):
        (JSC::JSWebAssemblyTable::clearFunction):
        * wasm/js/JSWebAssemblyTable.h:
        * wasm/js/WasmToJS.cpp:
        (JSC::Wasm::materializeImportJSCell):
        (JSC::Wasm::handleBadI64Use):
        (JSC::Wasm::wasmToJS):
        * wasm/js/WebAssemblyFunctionBase.h:
        * wasm/js/WebAssemblyModuleRecord.cpp:
        (JSC::WebAssemblyModuleRecord::link):
        (JSC::WebAssemblyModuleRecord::evaluate):
        * wasm/js/WebAssemblyModuleRecord.h:
        * wasm/js/WebAssemblyToJSCallee.h:
        * wasm/js/WebAssemblyWrapperFunction.h:

2018-01-12  Saam Barati  <sbarati@apple.com>

        CheckStructure can be incorrectly subsumed by CheckStructureOrEmpty
        https://bugs.webkit.org/show_bug.cgi?id=181177
        <rdar://problem/36205704>

        Reviewed by Yusuke Suzuki.

        The semantics of CheckStructure are such that it does not allow the empty value to flow through it.
        However, we may eliminate a CheckStructure if it's preceded by a CheckStructureOrEmpty. This doesn't
        have semantic consequences when validation is turned off. However, with validation on, this trips up
        our OSR exit machinery that says when an exit is allowed to happen.
        
        Consider the following IR:
        
        a: GetClosureVar // Or any other node that produces BytecodeTop
        ...
        c: CheckStructure(Cell:@a, {s2})
        d: PutByOffset(KnownCell:@a, KnownCell:@a, @value)
        
        In the TypeCheckHoistingPhase, we may insert CheckStructureOrEmptys like this:
        a: GetClosureVar
        e: CheckStructureOrEmpty(@a, {s1})
        ...
        f: CheckStructureOrEmpty(@a, {s2})
        c: CheckStructure(Cell:@a, {s2})
        d: PutByOffset(KnownCell:@a, KnownCell:@a, @value)
        
        This will cause constant folding to change the IR to:
        a: GetClosureVar
        e: CheckStructureOrEmpty(@a, {s1})
        ...
        f: CheckStructureOrEmpty(@a, {s2})
        d: PutByOffset(KnownCell:@a, KnownCell:@a, @value)
        
        Our mayExit analysis determines that the PutByOffset should not exit. Note
        that AI will determine the only value the PutByOffset can see in @a is 
        the empty value. Because KnownCell filters SpecCell and not SpecCellCheck,
        when lowering the PutByOffset, we reach a contradiction in AI and emit
        an OSR exit. However, because mayExit said we couldn't exit, we assert.
        
        Note that if we did not run the TypeCheckHoistingPhase on this IR, AI
        would have determined we would OSR exit at the second CheckStructure.
        
        This patch makes it so constant folding produces the following IR:
        a: GetClosureVar
        e: CheckStructureOrEmpty(@a, {s1})
        g: AssertNotEmpty(@a)
        ...
        f: CheckStructureOrEmpty(@a, {s2})
        h: AssertNotEmpty(@a)
        d: PutByOffset(KnownCell:@a, KnownCell:@a, @value)
        
        This modification will cause AI to know we will OSR exit before even reaching
        the PutByOffset. Note that in the original IR, the GetClosureVar won't
        actually produce the TDZ value. If it did, bytecode would have caused us
        to emit a CheckNotEmpty before the CheckStructure/PutByOffset combo. That's
        why this bug is about IR bookkeeping and not an actual error in IR analysis.
        This patch introduces AssertNotEmpty instead of using CheckNotEmpty to be
        more congruous with CheckStructure's semantics of crashing on the empty value
        as input (on 64 bit platforms).

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGConstantFoldingPhase.cpp:
        (JSC::DFG::ConstantFoldingPhase::foldConstants):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGNodeType.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileAssertNotEmpty):

2018-01-12  Joseph Pecoraro  <pecoraro@apple.com>

        Web Inspector: Remove unnecessary raw pointer in InspectorConsoleAgent
        https://bugs.webkit.org/show_bug.cgi?id=181579
        <rdar://problem/36193759>

        Reviewed by Brian Burg.

        * inspector/agents/InspectorConsoleAgent.h:
        * inspector/agents/InspectorConsoleAgent.cpp:
        (Inspector::InspectorConsoleAgent::clearMessages):
        (Inspector::InspectorConsoleAgent::addConsoleMessage):
        Switch from a raw pointer to m_consoleMessages.last().
        Also move the expiration check into the if block since it can only
        happen inside here when the number of console messages changes.

        (Inspector::InspectorConsoleAgent::discardValues):
        Also clear the expired message count when messages are cleared.

2018-01-12  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Create parallel SlotVisitors apriori
        https://bugs.webkit.org/show_bug.cgi?id=180907

        Reviewed by Saam Barati.

        The number of SlotVisitors are capped with the number of HeapHelperPool's threads + 2.
        If we create these SlotVisitors apropri, we do not need to create SlotVisitors dynamically.
        Then we do not need to grab locks while iterating all the SlotVisitors.

        In addition, we do not need to consider the case that the number of SlotVisitors increases
        after setting up VisitCounters in MarkingConstraintSolver since the number of SlotVisitors
        does not increase any more.

        * heap/Heap.cpp:
        (JSC::Heap::Heap):
        (JSC::Heap::runBeginPhase):
        * heap/Heap.h:
        * heap/HeapInlines.h:
        (JSC::Heap::forEachSlotVisitor):
        (JSC::Heap::numberOfSlotVisitors): Deleted.
        * heap/MarkingConstraintSolver.cpp:
        (JSC::MarkingConstraintSolver::didVisitSomething const):

2018-01-12  Saam Barati  <sbarati@apple.com>

        Each variant of a polymorphic inlined call should be exitOK at the top of the block
        https://bugs.webkit.org/show_bug.cgi?id=181562
        <rdar://problem/36445624>

        Reviewed by Yusuke Suzuki.

        Before this patch, the very first block in the switch for polymorphic call
        inlining will have exitOK at the top. The others are not guaranteed to.
        That was just a bug. They're all exitOK at the top. This will lead to crashes
        in FixupPhase because we won't have a node in a block that has ExitOK, so
        when we fixup various type checks, we assert out.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleInlining):

2018-01-11  Keith Miller  <keith_miller@apple.com>

        Rename ENABLE_ASYNC_ITERATION to ENABLE_JS_ASYNC_ITERATION
        https://bugs.webkit.org/show_bug.cgi?id=181573

        Reviewed by Simon Fraser.

        * Configurations/FeatureDefines.xcconfig:
        * runtime/Options.h:

2018-01-11  Michael Saboff  <msaboff@apple.com>

        REGRESSION(226788): AppStore Crashed @ JavaScriptCore: JSC::MacroAssemblerARM64::pushToSaveImmediateWithoutTouchingRegisters
        https://bugs.webkit.org/show_bug.cgi?id=181570

        Reviewed by Keith Miller.

        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::abortWithReason):
        Reverting these functions to use dataTempRegister and memoryTempRegister as they are
        JIT release asserts that will crash the program.

        (JSC::MacroAssemblerARM64::pushToSaveImmediateWithoutTouchingRegisters):
        Changed this so that it invalidates any cached dataTmpRegister contents if temp register
        caching is enabled.

2018-01-11  Filip Pizlo  <fpizlo@apple.com>

        Rename MarkedAllocator to BlockDirectory and AllocatorAttributes to CellAttributes
        https://bugs.webkit.org/show_bug.cgi?id=181543

        Rubber stamped by Michael Saboff.
        
        In a world that has thread-local caches, the thing we now call the "MarkedAllocator" doesn't
        really have anything to do with allocation anymore. The allocation will be done by something
        in the TLC. When you move the allocation logic out of MarkedAllocator, it becomes just a
        place to find blocks (a "block directory").

        Once we do that renaming, the term "allocator attributes" becomes weird. Those are really the
        attributes of the HeapCellType. So let's call them CellAttributes.

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * bytecode/AccessCase.cpp:
        (JSC::AccessCase::generateImpl):
        * bytecode/ObjectAllocationProfile.h:
        * bytecode/ObjectAllocationProfileInlines.h:
        (JSC::ObjectAllocationProfile::initializeProfile):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::emitAllocateRawObject):
        (JSC::DFG::SpeculativeJIT::compileMakeRope):
        (JSC::DFG::SpeculativeJIT::compileAllocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileReallocatePropertyStorage):
        (JSC::DFG::SpeculativeJIT::compileNewObject):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::emitAllocateJSCell):
        (JSC::DFG::SpeculativeJIT::emitAllocateJSObject):
        * ftl/FTLAbstractHeapRepository.h:
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileMakeRope):
        (JSC::FTL::DFG::LowerDFGToB3::compileMaterializeNewObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatePropertyStorageWithSizeImpl):
        (JSC::FTL::DFG::LowerDFGToB3::allocateHeapCell):
        (JSC::FTL::DFG::LowerDFGToB3::allocateObject):
        (JSC::FTL::DFG::LowerDFGToB3::allocatorForSize):
        * heap/AlignedMemoryAllocator.cpp:
        (JSC::AlignedMemoryAllocator::registerDirectory):
        (JSC::AlignedMemoryAllocator::registerAllocator): Deleted.
        * heap/AlignedMemoryAllocator.h:
        (JSC::AlignedMemoryAllocator::firstDirectory const):
        (JSC::AlignedMemoryAllocator::firstAllocator const): Deleted.
        * heap/AllocatorAttributes.cpp: Removed.
        * heap/AllocatorAttributes.h: Removed.
        * heap/BlockDirectory.cpp: Copied from Source/JavaScriptCore/heap/MarkedAllocator.cpp.
        (JSC::BlockDirectory::BlockDirectory):
        (JSC::BlockDirectory::setSubspace):
        (JSC::BlockDirectory::isPagedOut):
        (JSC::BlockDirectory::findEmptyBlockToSteal):
        (JSC::BlockDirectory::didConsumeFreeList):
        (JSC::BlockDirectory::tryAllocateWithoutCollecting):
        (JSC::BlockDirectory::allocateIn):
        (JSC::BlockDirectory::tryAllocateIn):
        (JSC::BlockDirectory::doTestCollectionsIfNeeded):
        (JSC::BlockDirectory::allocateSlowCase):
        (JSC::BlockDirectory::blockSizeForBytes):
        (JSC::BlockDirectory::tryAllocateBlock):
        (JSC::BlockDirectory::addBlock):
        (JSC::BlockDirectory::removeBlock):
        (JSC::BlockDirectory::stopAllocating):
        (JSC::BlockDirectory::prepareForAllocation):
        (JSC::BlockDirectory::lastChanceToFinalize):
        (JSC::BlockDirectory::resumeAllocating):
        (JSC::BlockDirectory::beginMarkingForFullCollection):
        (JSC::BlockDirectory::endMarking):
        (JSC::BlockDirectory::snapshotUnsweptForEdenCollection):
        (JSC::BlockDirectory::snapshotUnsweptForFullCollection):
        (JSC::BlockDirectory::findBlockToSweep):
        (JSC::BlockDirectory::sweep):
        (JSC::BlockDirectory::shrink):
        (JSC::BlockDirectory::assertNoUnswept):
        (JSC::BlockDirectory::parallelNotEmptyBlockSource):
        (JSC::BlockDirectory::dump const):
        (JSC::BlockDirectory::dumpBits):
        (JSC::BlockDirectory::markedSpace const):
        (JSC::MarkedAllocator::MarkedAllocator): Deleted.
        (JSC::MarkedAllocator::setSubspace): Deleted.
        (JSC::MarkedAllocator::isPagedOut): Deleted.
        (JSC::MarkedAllocator::findEmptyBlockToSteal): Deleted.
        (JSC::MarkedAllocator::didConsumeFreeList): Deleted.
        (JSC::MarkedAllocator::tryAllocateWithoutCollecting): Deleted.
        (JSC::MarkedAllocator::allocateIn): Deleted.
        (JSC::MarkedAllocator::tryAllocateIn): Deleted.
        (JSC::MarkedAllocator::doTestCollectionsIfNeeded): Deleted.
        (JSC::MarkedAllocator::allocateSlowCase): Deleted.
        (JSC::MarkedAllocator::blockSizeForBytes): Deleted.
        (JSC::MarkedAllocator::tryAllocateBlock): Deleted.
        (JSC::MarkedAllocator::addBlock): Deleted.
        (JSC::MarkedAllocator::removeBlock): Deleted.
        (JSC::MarkedAllocator::stopAllocating): Deleted.
        (JSC::MarkedAllocator::prepareForAllocation): Deleted.
        (JSC::MarkedAllocator::lastChanceToFinalize): Deleted.
        (JSC::MarkedAllocator::resumeAllocating): Deleted.
        (JSC::MarkedAllocator::beginMarkingForFullCollection): Deleted.
        (JSC::MarkedAllocator::endMarking): Deleted.
        (JSC::MarkedAllocator::snapshotUnsweptForEdenCollection): Deleted.
        (JSC::MarkedAllocator::snapshotUnsweptForFullCollection): Deleted.
        (JSC::MarkedAllocator::findBlockToSweep): Deleted.
        (JSC::MarkedAllocator::sweep): Deleted.
        (JSC::MarkedAllocator::shrink): Deleted.
        (JSC::MarkedAllocator::assertNoUnswept): Deleted.
        (JSC::MarkedAllocator::parallelNotEmptyBlockSource): Deleted.
        (JSC::MarkedAllocator::dump const): Deleted.
        (JSC::MarkedAllocator::dumpBits): Deleted.
        (JSC::MarkedAllocator::markedSpace const): Deleted.
        * heap/BlockDirectory.h: Copied from Source/JavaScriptCore/heap/MarkedAllocator.h.
        (JSC::BlockDirectory::attributes const):
        (JSC::BlockDirectory::forEachBitVector):
        (JSC::BlockDirectory::forEachBitVectorWithName):
        (JSC::BlockDirectory::nextDirectory const):
        (JSC::BlockDirectory::nextDirectoryInSubspace const):
        (JSC::BlockDirectory::nextDirectoryInAlignedMemoryAllocator const):
        (JSC::BlockDirectory::setNextDirectory):
        (JSC::BlockDirectory::setNextDirectoryInSubspace):
        (JSC::BlockDirectory::setNextDirectoryInAlignedMemoryAllocator):
        (JSC::BlockDirectory::offsetOfFreeList):
        (JSC::BlockDirectory::offsetOfCellSize):
        (JSC::MarkedAllocator::cellSize const): Deleted.
        (JSC::MarkedAllocator::attributes const): Deleted.
        (JSC::MarkedAllocator::needsDestruction const): Deleted.
        (JSC::MarkedAllocator::destruction const): Deleted.
        (JSC::MarkedAllocator::cellKind const): Deleted.
        (JSC::MarkedAllocator::heap): Deleted.
        (JSC::MarkedAllocator::bitvectorLock): Deleted.
        (JSC::MarkedAllocator::forEachBitVector): Deleted.
        (JSC::MarkedAllocator::forEachBitVectorWithName): Deleted.
        (JSC::MarkedAllocator::nextAllocator const): Deleted.
        (JSC::MarkedAllocator::nextAllocatorInSubspace const): Deleted.
        (JSC::MarkedAllocator::nextAllocatorInAlignedMemoryAllocator const): Deleted.
        (JSC::MarkedAllocator::setNextAllocator): Deleted.
        (JSC::MarkedAllocator::setNextAllocatorInSubspace): Deleted.
        (JSC::MarkedAllocator::setNextAllocatorInAlignedMemoryAllocator): Deleted.
        (JSC::MarkedAllocator::subspace const): Deleted.
        (JSC::MarkedAllocator::freeList const): Deleted.
        (JSC::MarkedAllocator::offsetOfFreeList): Deleted.
        (JSC::MarkedAllocator::offsetOfCellSize): Deleted.
        * heap/BlockDirectoryInlines.h: Copied from Source/JavaScriptCore/heap/MarkedAllocatorInlines.h.
        (JSC::BlockDirectory::isFreeListedCell const):
        (JSC::BlockDirectory::allocate):
        (JSC::BlockDirectory::forEachBlock):
        (JSC::BlockDirectory::forEachNotEmptyBlock):
        (JSC::MarkedAllocator::isFreeListedCell const): Deleted.
        (JSC::MarkedAllocator::allocate): Deleted.
        (JSC::MarkedAllocator::forEachBlock): Deleted.
        (JSC::MarkedAllocator::forEachNotEmptyBlock): Deleted.
        * heap/CellAttributes.cpp: Copied from Source/JavaScriptCore/heap/AllocatorAttributes.cpp.
        (JSC::CellAttributes::dump const):
        (JSC::AllocatorAttributes::dump const): Deleted.
        * heap/CellAttributes.h: Copied from Source/JavaScriptCore/heap/AllocatorAttributes.h.
        (JSC::CellAttributes::CellAttributes):
        (JSC::AllocatorAttributes::AllocatorAttributes): Deleted.
        * heap/CompleteSubspace.cpp:
        (JSC::CompleteSubspace::allocatorFor):
        (JSC::CompleteSubspace::allocateNonVirtual):
        (JSC::CompleteSubspace::allocatorForSlow):
        (JSC::CompleteSubspace::tryAllocateSlow):
        * heap/CompleteSubspace.h:
        (JSC::CompleteSubspace::allocatorForSizeStep):
        (JSC::CompleteSubspace::allocatorForNonVirtual):
        * heap/GCDeferralContext.h:
        * heap/Heap.cpp:
        (JSC::Heap::updateAllocationLimits):
        * heap/Heap.h:
        * heap/HeapCell.h:
        * heap/HeapCellInlines.h:
        (JSC::HeapCell::cellAttributes const):
        (JSC::HeapCell::destructionMode const):
        (JSC::HeapCell::cellKind const):
        (JSC::HeapCell::allocatorAttributes const): Deleted.
        * heap/HeapCellType.cpp:
        (JSC::HeapCellType::HeapCellType):
        * heap/HeapCellType.h:
        (JSC::HeapCellType::attributes const):
        * heap/IncrementalSweeper.cpp:
        (JSC::IncrementalSweeper::IncrementalSweeper):
        (JSC::IncrementalSweeper::sweepNextBlock):
        (JSC::IncrementalSweeper::startSweeping):
        (JSC::IncrementalSweeper::stopSweeping):
        * heap/IncrementalSweeper.h:
        * heap/IsoCellSet.cpp:
        (JSC::IsoCellSet::IsoCellSet):
        (JSC::IsoCellSet::parallelNotEmptyMarkedBlockSource):
        (JSC::IsoCellSet::addSlow):
        (JSC::IsoCellSet::didRemoveBlock):
        (JSC::IsoCellSet::sweepToFreeList):
        * heap/IsoCellSetInlines.h:
        (JSC::IsoCellSet::forEachMarkedCell):
        (JSC::IsoCellSet::forEachLiveCell):
        * heap/IsoSubspace.cpp:
        (JSC::IsoSubspace::IsoSubspace):
        (JSC::IsoSubspace::allocatorFor):
        (JSC::IsoSubspace::allocateNonVirtual):
        * heap/IsoSubspace.h:
        (JSC::IsoSubspace::allocatorForNonVirtual):
        * heap/LargeAllocation.h:
        (JSC::LargeAllocation::attributes const):
        * heap/MarkedAllocator.cpp: Removed.
        * heap/MarkedAllocator.h: Removed.
        * heap/MarkedAllocatorInlines.h: Removed.
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::Handle::~Handle):
        (JSC::MarkedBlock::Handle::setIsFreeListed):
        (JSC::MarkedBlock::Handle::stopAllocating):
        (JSC::MarkedBlock::Handle::lastChanceToFinalize):
        (JSC::MarkedBlock::Handle::resumeAllocating):
        (JSC::MarkedBlock::aboutToMarkSlow):
        (JSC::MarkedBlock::Handle::didConsumeFreeList):
        (JSC::MarkedBlock::noteMarkedSlow):
        (JSC::MarkedBlock::Handle::removeFromDirectory):
        (JSC::MarkedBlock::Handle::didAddToDirectory):
        (JSC::MarkedBlock::Handle::didRemoveFromDirectory):
        (JSC::MarkedBlock::Handle::dumpState):
        (JSC::MarkedBlock::Handle::subspace const):
        (JSC::MarkedBlock::Handle::sweep):
        (JSC::MarkedBlock::Handle::isFreeListedCell const):
        (JSC::MarkedBlock::Handle::removeFromAllocator): Deleted.
        (JSC::MarkedBlock::Handle::didAddToAllocator): Deleted.
        (JSC::MarkedBlock::Handle::didRemoveFromAllocator): Deleted.
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::Handle::directory const):
        (JSC::MarkedBlock::Handle::attributes const):
        (JSC::MarkedBlock::attributes const):
        (JSC::MarkedBlock::Handle::allocator const): Deleted.
        * heap/MarkedBlockInlines.h:
        (JSC::MarkedBlock::Handle::isAllocated):
        (JSC::MarkedBlock::Handle::isLive):
        (JSC::MarkedBlock::Handle::specializedSweep):
        (JSC::MarkedBlock::Handle::isEmpty):
        * heap/MarkedSpace.cpp:
        (JSC::MarkedSpace::lastChanceToFinalize):
        (JSC::MarkedSpace::sweep):
        (JSC::MarkedSpace::stopAllocating):
        (JSC::MarkedSpace::resumeAllocating):
        (JSC::MarkedSpace::isPagedOut):
        (JSC::MarkedSpace::freeBlock):
        (JSC::MarkedSpace::shrink):
        (JSC::MarkedSpace::beginMarking):
        (JSC::MarkedSpace::endMarking):
        (JSC::MarkedSpace::snapshotUnswept):
        (JSC::MarkedSpace::assertNoUnswept):
        (JSC::MarkedSpace::dumpBits):
        (JSC::MarkedSpace::addBlockDirectory):
        (JSC::MarkedSpace::addMarkedAllocator): Deleted.
        * heap/MarkedSpace.h:
        (JSC::MarkedSpace::firstDirectory const):
        (JSC::MarkedSpace::directoryLock):
        (JSC::MarkedSpace::forEachBlock):
        (JSC::MarkedSpace::forEachDirectory):
        (JSC::MarkedSpace::firstAllocator const): Deleted.
        (JSC::MarkedSpace::allocatorLock): Deleted.
        (JSC::MarkedSpace::forEachAllocator): Deleted.
        * heap/MarkedSpaceInlines.h:
        * heap/Subspace.cpp:
        (JSC::Subspace::initialize):
        (JSC::Subspace::prepareForAllocation):
        (JSC::Subspace::findEmptyBlockToSteal):
        (JSC::Subspace::parallelDirectorySource):
        (JSC::Subspace::parallelNotEmptyMarkedBlockSource):
        (JSC::Subspace::sweep):
        (JSC::Subspace::parallelAllocatorSource): Deleted.
        * heap/Subspace.h:
        (JSC::Subspace::attributes const):
        (JSC::Subspace::didCreateFirstDirectory):
        (JSC::Subspace::didCreateFirstAllocator): Deleted.
        * heap/SubspaceInlines.h:
        (JSC::Subspace::forEachDirectory):
        (JSC::Subspace::forEachMarkedBlock):
        (JSC::Subspace::forEachNotEmptyMarkedBlock):
        (JSC::Subspace::forEachAllocator): Deleted.
        * jit/AssemblyHelpers.h:
        (JSC::AssemblyHelpers::emitAllocateWithNonNullAllocator):
        (JSC::AssemblyHelpers::emitAllocate):
        (JSC::AssemblyHelpers::emitAllocateJSCell):
        (JSC::AssemblyHelpers::emitAllocateJSObject):
        (JSC::AssemblyHelpers::emitAllocateJSObjectWithKnownSize):
        * jit/JIT.h:
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_new_object):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emit_op_new_object):
        * runtime/JSDestructibleObjectHeapCellType.cpp:
        (JSC::JSDestructibleObjectHeapCellType::JSDestructibleObjectHeapCellType):
        * runtime/JSSegmentedVariableObjectHeapCellType.cpp:
        (JSC::JSSegmentedVariableObjectHeapCellType::JSSegmentedVariableObjectHeapCellType):
        * runtime/JSStringHeapCellType.cpp:
        (JSC::JSStringHeapCellType::JSStringHeapCellType):
        * runtime/VM.cpp:
        (JSC::VM::VM):
        * wasm/js/JSWebAssemblyCodeBlockHeapCellType.cpp:
        (JSC::JSWebAssemblyCodeBlockHeapCellType::JSWebAssemblyCodeBlockHeapCellType):

2018-01-11  Saam Barati  <sbarati@apple.com>

        When inserting Unreachable in byte code parser we need to flush all the right things
        https://bugs.webkit.org/show_bug.cgi?id=181509
        <rdar://problem/36423110>

        Reviewed by Mark Lam.

        I added code in r226655 that had its own mechanism for preserving liveness when
        inserting Unreachable nodes after ForceOSRExit. There are two ways to preserve
        liveness: PhantomLocal and Flush. Certain values *must* be flushed to the stack.
        I got some of these values wrong, which was leading to a crash when recovering the
        callee value from an inlined frame. Instead of making the same mistake and repeating
        similar code again, this patch refactors this logic to be shared with the other
        liveness preservation code in the DFG bytecode parser. This is what I should have
        done in my initial patch.

        * bytecode/InlineCallFrame.h:
        (JSC::remapOperand):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::flushImpl):
        (JSC::DFG::flushForTerminalImpl):
        (JSC::DFG::ByteCodeParser::flush):
        (JSC::DFG::ByteCodeParser::flushForTerminal):
        (JSC::DFG::ByteCodeParser::parse):

2018-01-11  Saam Barati  <sbarati@apple.com>

        JITMathIC code in the FTL is wrong when code gets duplicated
        https://bugs.webkit.org/show_bug.cgi?id=181525
        <rdar://problem/36351993>

        Reviewed by Michael Saboff and Keith Miller.

        B3/Air may duplicate code for various reasons. Patchpoint generators inside
        FTLLower must be aware that they can be called multiple times because of this.
        The patchpoint for math ICs was not aware of this, and shared state amongst
        all invocations of the patchpoint's generator. This patch fixes this bug so
        that each invocation of the patchpoint's generator gets a unique math IC.

        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::addMathIC):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileValueAdd):
        (JSC::FTL::DFG::LowerDFGToB3::compileUnaryMathIC):
        (JSC::FTL::DFG::LowerDFGToB3::compileBinaryMathIC):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithAddOrSub):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithMul):
        (JSC::FTL::DFG::LowerDFGToB3::compileArithNegate):
        (JSC::FTL::DFG::LowerDFGToB3::compileMathIC): Deleted.
        * jit/JITMathIC.h:
        (JSC::isProfileEmpty):

2018-01-11  Michael Saboff  <msaboff@apple.com>

        Ensure there are no unsafe uses of MacroAssemblerARM64::dataTempRegister
        https://bugs.webkit.org/show_bug.cgi?id=181512

        Reviewed by Saam Barati.

        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::abortWithReason):
        (JSC::MacroAssemblerARM64::pushToSaveImmediateWithoutTouchingRegisters):
        All current uses of dataTempRegister in these functions are safe, but it makes sense to
        fix them in case they might be used elsewhere.

2018-01-04  Filip Pizlo  <fpizlo@apple.com>

        CodeBlocks should be in IsoSubspaces
        https://bugs.webkit.org/show_bug.cgi?id=180884

        Reviewed by Saam Barati.
        
        This moves CodeBlocks into IsoSubspaces. Doing so means that we no longer need to have the
        special CodeBlockSet HashSets of new and old CodeBlocks. We also no longer use
        WeakReferenceHarvester or UnconditionalFinalizer. Instead:
        
        - Code block sweeping is now just eager sweeping. This means that it automatically takes
          advantage of our unswept set, which roughly corresponds to what CodeBlockSet used to use
          its eden set for.
        
        - Those idea of Executable "weakly visiting" the CodeBlock is replaced by Executable
          marking a ExecutableToCodeBlockEdge object. That object being marked corresponds to what
          we used to call CodeBlock "having been weakly visited". This means that CodeBlockSet no
          longer has to clear the set of weakly visited code blocks. This also means that
          determining CodeBlock liveness, propagating CodeBlock transitions, and jettisoning
          CodeBlocks during GC are now the edge's job. The edge is also in an IsoSubspace and it
          has IsoCellSets to tell us which edges have output constraints (what we used to call
          CodeBlock's weak reference harvester) and which have unconditional finalizers.
        
        - CodeBlock now uses an IsoCellSet to tell if it has an unconditional finalizer.
        
        - CodeBlockSet still exists!  It has one unified HashSet of CodeBlocks that we use to
          handle requests from the sampler, debugger, and other facilities. They may want to ask
          if some pointer corresponds to a CodeBlock during stages of execution during which the
          GC is unable to answer isLive() queries. The trickiest is the sampling profiler thread.
          There is no way that the GC's isLive could tell us of a CodeBlock that had already been
          allocated has now been full constructed.
        
        Rolling this back in because it was rolled out by mistake. There was a flaky crash that was
        happening before and after this change, but we misread the revision numbers at first and
        thought that this was the cause.
        
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::CodeBlock):
        (JSC::CodeBlock::finishCreation):
        (JSC::CodeBlock::finishCreationCommon):
        (JSC::CodeBlock::~CodeBlock):
        (JSC::CodeBlock::visitChildren):
        (JSC::CodeBlock::propagateTransitions):
        (JSC::CodeBlock::determineLiveness):
        (JSC::CodeBlock::finalizeUnconditionally):
        (JSC::CodeBlock::stronglyVisitStrongReferences):
        (JSC::CodeBlock::hasInstalledVMTrapBreakpoints const):
        (JSC::CodeBlock::installVMTrapBreakpoints):
        (JSC::CodeBlock::dumpMathICStats):
        (JSC::CodeBlock::visitWeakly): Deleted.
        (JSC::CodeBlock::WeakReferenceHarvester::visitWeakReferences): Deleted.
        (JSC::CodeBlock::UnconditionalFinalizer::finalizeUnconditionally): Deleted.
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::subspaceFor):
        (JSC::CodeBlock::ownerEdge const):
        (JSC::CodeBlock::clearVisitWeaklyHasBeenCalled): Deleted.
        * bytecode/EvalCodeBlock.h:
        (JSC::EvalCodeBlock::create): Deleted.
        (JSC::EvalCodeBlock::createStructure): Deleted.
        (JSC::EvalCodeBlock::variable): Deleted.
        (JSC::EvalCodeBlock::numVariables): Deleted.
        (JSC::EvalCodeBlock::functionHoistingCandidate): Deleted.
        (JSC::EvalCodeBlock::numFunctionHoistingCandidates): Deleted.
        (JSC::EvalCodeBlock::EvalCodeBlock): Deleted.
        (JSC::EvalCodeBlock::unlinkedEvalCodeBlock const): Deleted.
        * bytecode/ExecutableToCodeBlockEdge.cpp: Added.
        (JSC::ExecutableToCodeBlockEdge::createStructure):
        (JSC::ExecutableToCodeBlockEdge::create):
        (JSC::ExecutableToCodeBlockEdge::visitChildren):
        (JSC::ExecutableToCodeBlockEdge::visitOutputConstraints):
        (JSC::ExecutableToCodeBlockEdge::finalizeUnconditionally):
        (JSC::ExecutableToCodeBlockEdge::activate):
        (JSC::ExecutableToCodeBlockEdge::deactivate):
        (JSC::ExecutableToCodeBlockEdge::deactivateAndUnwrap):
        (JSC::ExecutableToCodeBlockEdge::wrap):
        (JSC::ExecutableToCodeBlockEdge::wrapAndActivate):
        (JSC::ExecutableToCodeBlockEdge::ExecutableToCodeBlockEdge):
        (JSC::ExecutableToCodeBlockEdge::runConstraint):
        * bytecode/ExecutableToCodeBlockEdge.h: Added.
        (JSC::ExecutableToCodeBlockEdge::subspaceFor):
        (JSC::ExecutableToCodeBlockEdge::codeBlock const):
        (JSC::ExecutableToCodeBlockEdge::unwrap):
        * bytecode/FunctionCodeBlock.h:
        (JSC::FunctionCodeBlock::subspaceFor):
        (JSC::FunctionCodeBlock::createStructure):
        * bytecode/ModuleProgramCodeBlock.h:
        (JSC::ModuleProgramCodeBlock::create): Deleted.
        (JSC::ModuleProgramCodeBlock::createStructure): Deleted.
        (JSC::ModuleProgramCodeBlock::ModuleProgramCodeBlock): Deleted.
        * bytecode/ProgramCodeBlock.h:
        (JSC::ProgramCodeBlock::create): Deleted.
        (JSC::ProgramCodeBlock::createStructure): Deleted.
        (JSC::ProgramCodeBlock::ProgramCodeBlock): Deleted.
        * debugger/Debugger.cpp:
        (JSC::Debugger::SetSteppingModeFunctor::operator() const):
        (JSC::Debugger::ToggleBreakpointFunctor::operator() const):
        (JSC::Debugger::ClearCodeBlockDebuggerRequestsFunctor::operator() const):
        (JSC::Debugger::ClearDebuggerRequestsFunctor::operator() const):
        * heap/CodeBlockSet.cpp:
        (JSC::CodeBlockSet::contains):
        (JSC::CodeBlockSet::dump const):
        (JSC::CodeBlockSet::add):
        (JSC::CodeBlockSet::remove):
        (JSC::CodeBlockSet::promoteYoungCodeBlocks): Deleted.
        (JSC::CodeBlockSet::clearMarksForFullCollection): Deleted.
        (JSC::CodeBlockSet::lastChanceToFinalize): Deleted.
        (JSC::CodeBlockSet::deleteUnmarkedAndUnreferenced): Deleted.
        * heap/CodeBlockSet.h:
        * heap/CodeBlockSetInlines.h:
        (JSC::CodeBlockSet::iterate):
        (JSC::CodeBlockSet::iterateViaSubspaces):
        * heap/ConservativeRoots.cpp:
        (JSC::ConservativeRoots::genericAddPointer):
        (JSC::DummyMarkHook::markKnownJSCell):
        (JSC::CompositeMarkHook::mark):
        (JSC::CompositeMarkHook::markKnownJSCell):
        * heap/ConservativeRoots.h:
        * heap/Heap.cpp:
        (JSC::Heap::lastChanceToFinalize):
        (JSC::Heap::finalizeMarkedUnconditionalFinalizers):
        (JSC::Heap::finalizeUnconditionalFinalizers):
        (JSC::Heap::beginMarking):
        (JSC::Heap::deleteUnmarkedCompiledCode):
        (JSC::Heap::sweepInFinalize):
        (JSC::Heap::forEachCodeBlockImpl):
        (JSC::Heap::forEachCodeBlockIgnoringJITPlansImpl):
        (JSC::Heap::addCoreConstraints):
        (JSC::Heap::finalizeUnconditionalFinalizersInIsoSubspace): Deleted.
        * heap/Heap.h:
        * heap/HeapCell.h:
        * heap/HeapCellInlines.h:
        (JSC::HeapCell::subspace const):
        * heap/HeapInlines.h:
        (JSC::Heap::forEachCodeBlock):
        (JSC::Heap::forEachCodeBlockIgnoringJITPlans):
        * heap/HeapUtil.h:
        (JSC::HeapUtil::findGCObjectPointersForMarking):
        * heap/IsoCellSet.cpp:
        (JSC::IsoCellSet::parallelNotEmptyMarkedBlockSource):
        * heap/IsoCellSet.h:
        * heap/IsoCellSetInlines.h:
        (JSC::IsoCellSet::forEachMarkedCellInParallel):
        (JSC::IsoCellSet::forEachLiveCell):
        * heap/LargeAllocation.h:
        (JSC::LargeAllocation::subspace const):
        * heap/MarkStackMergingConstraint.cpp:
        (JSC::MarkStackMergingConstraint::executeImpl):
        * heap/MarkStackMergingConstraint.h:
        * heap/MarkedAllocator.cpp:
        (JSC::MarkedAllocator::parallelNotEmptyBlockSource):
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::Handle::didAddToAllocator):
        (JSC::MarkedBlock::Handle::didRemoveFromAllocator):
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::subspace const):
        * heap/MarkedBlockInlines.h:
        (JSC::MarkedBlock::Handle::forEachLiveCell):
        * heap/MarkedSpaceInlines.h:
        (JSC::MarkedSpace::forEachLiveCell):
        * heap/MarkingConstraint.cpp:
        (JSC::MarkingConstraint::execute):
        (JSC::MarkingConstraint::doParallelWork):
        (JSC::MarkingConstraint::finishParallelWork): Deleted.
        (JSC::MarkingConstraint::doParallelWorkImpl): Deleted.
        (JSC::MarkingConstraint::finishParallelWorkImpl): Deleted.
        * heap/MarkingConstraint.h:
        * heap/MarkingConstraintSet.cpp:
        (JSC::MarkingConstraintSet::add):
        * heap/MarkingConstraintSet.h:
        (JSC::MarkingConstraintSet::add):
        * heap/MarkingConstraintSolver.cpp:
        (JSC::MarkingConstraintSolver::execute):
        (JSC::MarkingConstraintSolver::addParallelTask):
        (JSC::MarkingConstraintSolver::runExecutionThread):
        (JSC::MarkingConstraintSolver::didExecute): Deleted.
        * heap/MarkingConstraintSolver.h:
        (JSC::MarkingConstraintSolver::TaskWithConstraint::TaskWithConstraint):
        (JSC::MarkingConstraintSolver::TaskWithConstraint::operator== const):
        * heap/SimpleMarkingConstraint.cpp:
        (JSC::SimpleMarkingConstraint::SimpleMarkingConstraint):
        (JSC::SimpleMarkingConstraint::executeImpl):
        * heap/SimpleMarkingConstraint.h:
        (JSC::SimpleMarkingConstraint::SimpleMarkingConstraint):
        * heap/SlotVisitor.cpp:
        (JSC::SlotVisitor::addParallelConstraintTask):
        * heap/SlotVisitor.h:
        * heap/Subspace.cpp:
        (JSC::Subspace::sweep):
        * heap/Subspace.h:
        * heap/SubspaceInlines.h:
        (JSC::Subspace::forEachLiveCell):
        * llint/LowLevelInterpreter.asm:
        * runtime/EvalExecutable.cpp:
        (JSC::EvalExecutable::visitChildren):
        * runtime/EvalExecutable.h:
        (JSC::EvalExecutable::codeBlock):
        * runtime/FunctionExecutable.cpp:
        (JSC::FunctionExecutable::baselineCodeBlockFor):
        (JSC::FunctionExecutable::visitChildren):
        * runtime/FunctionExecutable.h:
        * runtime/JSType.h:
        * runtime/ModuleProgramExecutable.cpp:
        (JSC::ModuleProgramExecutable::visitChildren):
        * runtime/ModuleProgramExecutable.h:
        * runtime/ProgramExecutable.cpp:
        (JSC::ProgramExecutable::visitChildren):
        * runtime/ProgramExecutable.h:
        * runtime/ScriptExecutable.cpp:
        (JSC::ScriptExecutable::installCode):
        (JSC::ScriptExecutable::newReplacementCodeBlockFor):
        * runtime/VM.cpp:
        (JSC::VM::VM):
        * runtime/VM.h:
        (JSC::VM::SpaceAndFinalizerSet::SpaceAndFinalizerSet):
        (JSC::VM::SpaceAndFinalizerSet::finalizerSetFor):
        (JSC::VM::forEachCodeBlockSpace):
        * runtime/VMTraps.cpp:
        (JSC::VMTraps::handleTraps):
        * tools/VMInspector.cpp:
        (JSC::VMInspector::codeBlockForMachinePC):
        (JSC::VMInspector::isValidCodeBlock):

2018-01-11  Michael Saboff  <msaboff@apple.com>

        Add a DOM gadget for Spectre testing
        https://bugs.webkit.org/show_bug.cgi?id=181351

        Reviewed by Ryosuke Niwa.

        * runtime/Options.h:

2018-01-11  Yusuke Suzuki  <utatane.tea@gmail.com>

        [DFG][FTL] regExpMatchFast should be handled
        https://bugs.webkit.org/show_bug.cgi?id=180988

        Reviewed by Mark Lam.

        RegExp.prototype.@@match has a fast path, @regExpMatchFast. This patch annotates this function
        with RegExpMatchFastIntrinsic, and introduces RegExpMatch DFG node. This paves the way to
        make NewRegexp PhantomNewRegexp if it is not used except for setting/getting its lastIndex property.

        To improve RegExp.prototype.@@match's performance more, we make this builtin function small by moving
        slow path part to `@matchSlow()` private function.

        It improves SixSpeed regex-u.{es5,es6} largely since they stress String.prototype.match, which calls
        this regExpMatchFast function.

                                 baseline                  patched

        regex-u.es5          55.3835+-6.3002     ^     36.2431+-2.0797        ^ definitely 1.5281x faster
        regex-u.es6         110.4624+-6.2896     ^     94.1012+-7.2433        ^ definitely 1.1739x faster

        * builtins/RegExpPrototype.js:
        (globalPrivate.matchSlow):
        (overriddenName.string_appeared_here.match):
        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleIntrinsicCall):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::hasHeapPrediction):
        * dfg/DFGNodeType.h:
        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileRegExpMatch):
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileNode):
        (JSC::FTL::DFG::LowerDFGToB3::compileRegExpMatch):
        * runtime/Intrinsic.cpp:
        (JSC::intrinsicName):
        * runtime/Intrinsic.h:
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        * runtime/RegExpPrototype.cpp:
        (JSC::regExpProtoFuncMatchFast):

2018-01-11  Saam Barati  <sbarati@apple.com>

        Our for-in caching is wrong when we add indexed properties on things in the prototype chain
        https://bugs.webkit.org/show_bug.cgi?id=181508

        Reviewed by Yusuke Suzuki.

        Our for-in caching would cache structure chains that had prototypes with
        indexed properties. Clearly this is wrong. This caching breaks when a prototype
        adds new indexed properties. We would continue to enumerate the old cached
        state of properties, and not include the new indexed properties.
        
        The old code used to prevent caching only if the base structure had
        indexed properties. This patch extends it to prevent caching if the
        base, or any structure in the prototype chain, has indexed properties.

        * runtime/Structure.cpp:
        (JSC::Structure::canCachePropertyNameEnumerator const):

2018-01-10  JF Bastien  <jfbastien@apple.com>

        Poison small JSObject derivatives which only contain pointers
        https://bugs.webkit.org/show_bug.cgi?id=181483
        <rdar://problem/36407127>

        Reviewed by Mark Lam.

        I wrote a script that finds interesting things to poison or
        generally harden. These stood out because they derive from
        JSObject and only contain a few pointer or pointer-like fields,
        and could therefore just be poisoned. This also requires some
        template "improvements" to our poisoning machinery. Worth noting
        is that I'm making PoisonedUniquePtr move-assignable and
        move-constructible from unique_ptr, which makes it a better
        drop-in replacement because we don't need to use
        makePoisonedUniquePtr. This means function-locals can be
        unique_ptr and get the nice RAII pattern, and once the function is
        done you can just move to the class' PoisonedUniquePtr without
        worrying.

        * API/JSAPIWrapperObject.h:
        (JSC::JSAPIWrapperObject::wrappedObject):
        * API/JSAPIWrapperObject.mm:
        (JSC::JSAPIWrapperObject::JSAPIWrapperObject):
        * API/JSCallbackObject.h:
        * runtime/ArrayPrototype.h:
        * runtime/DateInstance.h:
        * runtime/JSArrayBuffer.cpp:
        (JSC::JSArrayBuffer::finishCreation):
        (JSC::JSArrayBuffer::isShared const):
        (JSC::JSArrayBuffer::sharingMode const):
        * runtime/JSArrayBuffer.h:
        * runtime/JSCPoison.h:

2018-01-10  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r226667 and r226673.
        https://bugs.webkit.org/show_bug.cgi?id=181488

        This caused a flaky crash. (Requested by mlewis13 on #webkit).

        Reverted changesets:

        "CodeBlocks should be in IsoSubspaces"
        https://bugs.webkit.org/show_bug.cgi?id=180884
        https://trac.webkit.org/changeset/226667

        "REGRESSION (r226667): CodeBlocks should be in IsoSubspaces"
        https://bugs.webkit.org/show_bug.cgi?id=180884
        https://trac.webkit.org/changeset/226673

2018-01-09  David Kilzer  <ddkilzer@apple.com>

        REGRESSION (r226667): CodeBlocks should be in IsoSubspaces
        <https://bugs.webkit.org/show_bug.cgi?id=180884>

        Fixes the following build error:

            heap/Heap.cpp:2708:10: error: lambda capture 'this' is not used [-Werror,-Wunused-lambda-capture]

        * heap/Heap.cpp:
        (JSC::Heap::addCoreConstraints): Remove 'this' from lambda to
        fix the build.

2018-01-09  Keith Miller  <keith_miller@apple.com>

        and32 with an Address source on ARM64 did not invalidate dataTempRegister
        https://bugs.webkit.org/show_bug.cgi?id=181467

        Reviewed by Michael Saboff.

        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::and32):

2018-01-04  Filip Pizlo  <fpizlo@apple.com>

        CodeBlocks should be in IsoSubspaces
        https://bugs.webkit.org/show_bug.cgi?id=180884

        Reviewed by Saam Barati.
        
        This moves CodeBlocks into IsoSubspaces. Doing so means that we no longer need to have the
        special CodeBlockSet HashSets of new and old CodeBlocks. We also no longer use
        WeakReferenceHarvester or UnconditionalFinalizer. Instead:
        
        - Code block sweeping is now just eager sweeping. This means that it automatically takes
          advantage of our unswept set, which roughly corresponds to what CodeBlockSet used to use
          its eden set for.
        
        - Those idea of Executable "weakly visiting" the CodeBlock is replaced by Executable
          marking a ExecutableToCodeBlockEdge object. That object being marked corresponds to what
          we used to call CodeBlock "having been weakly visited". This means that CodeBlockSet no
          longer has to clear the set of weakly visited code blocks. This also means that
          determining CodeBlock liveness, propagating CodeBlock transitions, and jettisoning
          CodeBlocks during GC are now the edge's job. The edge is also in an IsoSubspace and it
          has IsoCellSets to tell us which edges have output constraints (what we used to call
          CodeBlock's weak reference harvester) and which have unconditional finalizers.
        
        - CodeBlock now uses an IsoCellSet to tell if it has an unconditional finalizer.
        
        - CodeBlockSet still exists!  It has one unified HashSet of CodeBlocks that we use to
          handle requests from the sampler, debugger, and other facilities. They may want to ask
          if some pointer corresponds to a CodeBlock during stages of execution during which the
          GC is unable to answer isLive() queries. The trickiest is the sampling profiler thread.
          There is no way that the GC's isLive could tell us of a CodeBlock that had already been
          allocated has now been full constructed.
        
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::CodeBlock):
        (JSC::CodeBlock::finishCreation):
        (JSC::CodeBlock::finishCreationCommon):
        (JSC::CodeBlock::~CodeBlock):
        (JSC::CodeBlock::visitChildren):
        (JSC::CodeBlock::propagateTransitions):
        (JSC::CodeBlock::determineLiveness):
        (JSC::CodeBlock::finalizeUnconditionally):
        (JSC::CodeBlock::stronglyVisitStrongReferences):
        (JSC::CodeBlock::hasInstalledVMTrapBreakpoints const):
        (JSC::CodeBlock::installVMTrapBreakpoints):
        (JSC::CodeBlock::dumpMathICStats):
        (JSC::CodeBlock::visitWeakly): Deleted.
        (JSC::CodeBlock::WeakReferenceHarvester::visitWeakReferences): Deleted.
        (JSC::CodeBlock::UnconditionalFinalizer::finalizeUnconditionally): Deleted.
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::subspaceFor):
        (JSC::CodeBlock::ownerEdge const):
        (JSC::CodeBlock::clearVisitWeaklyHasBeenCalled): Deleted.
        * bytecode/EvalCodeBlock.h:
        (JSC::EvalCodeBlock::create): Deleted.
        (JSC::EvalCodeBlock::createStructure): Deleted.
        (JSC::EvalCodeBlock::variable): Deleted.
        (JSC::EvalCodeBlock::numVariables): Deleted.
        (JSC::EvalCodeBlock::functionHoistingCandidate): Deleted.
        (JSC::EvalCodeBlock::numFunctionHoistingCandidates): Deleted.
        (JSC::EvalCodeBlock::EvalCodeBlock): Deleted.
        (JSC::EvalCodeBlock::unlinkedEvalCodeBlock const): Deleted.
        * bytecode/ExecutableToCodeBlockEdge.cpp: Added.
        (JSC::ExecutableToCodeBlockEdge::createStructure):
        (JSC::ExecutableToCodeBlockEdge::create):
        (JSC::ExecutableToCodeBlockEdge::visitChildren):
        (JSC::ExecutableToCodeBlockEdge::visitOutputConstraints):
        (JSC::ExecutableToCodeBlockEdge::finalizeUnconditionally):
        (JSC::ExecutableToCodeBlockEdge::activate):
        (JSC::ExecutableToCodeBlockEdge::deactivate):
        (JSC::ExecutableToCodeBlockEdge::deactivateAndUnwrap):
        (JSC::ExecutableToCodeBlockEdge::wrap):
        (JSC::ExecutableToCodeBlockEdge::wrapAndActivate):
        (JSC::ExecutableToCodeBlockEdge::ExecutableToCodeBlockEdge):
        (JSC::ExecutableToCodeBlockEdge::runConstraint):
        * bytecode/ExecutableToCodeBlockEdge.h: Added.
        (JSC::ExecutableToCodeBlockEdge::subspaceFor):
        (JSC::ExecutableToCodeBlockEdge::codeBlock const):
        (JSC::ExecutableToCodeBlockEdge::unwrap):
        * bytecode/FunctionCodeBlock.h:
        (JSC::FunctionCodeBlock::subspaceFor):
        (JSC::FunctionCodeBlock::createStructure):
        * bytecode/ModuleProgramCodeBlock.h:
        (JSC::ModuleProgramCodeBlock::create): Deleted.
        (JSC::ModuleProgramCodeBlock::createStructure): Deleted.
        (JSC::ModuleProgramCodeBlock::ModuleProgramCodeBlock): Deleted.
        * bytecode/ProgramCodeBlock.h:
        (JSC::ProgramCodeBlock::create): Deleted.
        (JSC::ProgramCodeBlock::createStructure): Deleted.
        (JSC::ProgramCodeBlock::ProgramCodeBlock): Deleted.
        * debugger/Debugger.cpp:
        (JSC::Debugger::SetSteppingModeFunctor::operator() const):
        (JSC::Debugger::ToggleBreakpointFunctor::operator() const):
        (JSC::Debugger::ClearCodeBlockDebuggerRequestsFunctor::operator() const):
        (JSC::Debugger::ClearDebuggerRequestsFunctor::operator() const):
        * heap/CodeBlockSet.cpp:
        (JSC::CodeBlockSet::contains):
        (JSC::CodeBlockSet::dump const):
        (JSC::CodeBlockSet::add):
        (JSC::CodeBlockSet::remove):
        (JSC::CodeBlockSet::promoteYoungCodeBlocks): Deleted.
        (JSC::CodeBlockSet::clearMarksForFullCollection): Deleted.
        (JSC::CodeBlockSet::lastChanceToFinalize): Deleted.
        (JSC::CodeBlockSet::deleteUnmarkedAndUnreferenced): Deleted.
        * heap/CodeBlockSet.h:
        * heap/CodeBlockSetInlines.h:
        (JSC::CodeBlockSet::iterate):
        (JSC::CodeBlockSet::iterateViaSubspaces):
        * heap/ConservativeRoots.cpp:
        (JSC::ConservativeRoots::genericAddPointer):
        (JSC::DummyMarkHook::markKnownJSCell):
        (JSC::CompositeMarkHook::mark):
        (JSC::CompositeMarkHook::markKnownJSCell):
        * heap/ConservativeRoots.h:
        * heap/Heap.cpp:
        (JSC::Heap::lastChanceToFinalize):
        (JSC::Heap::finalizeMarkedUnconditionalFinalizers):
        (JSC::Heap::finalizeUnconditionalFinalizers):
        (JSC::Heap::beginMarking):
        (JSC::Heap::deleteUnmarkedCompiledCode):
        (JSC::Heap::sweepInFinalize):
        (JSC::Heap::forEachCodeBlockImpl):
        (JSC::Heap::forEachCodeBlockIgnoringJITPlansImpl):
        (JSC::Heap::addCoreConstraints):
        (JSC::Heap::finalizeUnconditionalFinalizersInIsoSubspace): Deleted.
        * heap/Heap.h:
        * heap/HeapCell.h:
        * heap/HeapCellInlines.h:
        (JSC::HeapCell::subspace const):
        * heap/HeapInlines.h:
        (JSC::Heap::forEachCodeBlock):
        (JSC::Heap::forEachCodeBlockIgnoringJITPlans):
        * heap/HeapUtil.h:
        (JSC::HeapUtil::findGCObjectPointersForMarking):
        * heap/IsoCellSet.cpp:
        (JSC::IsoCellSet::parallelNotEmptyMarkedBlockSource):
        * heap/IsoCellSet.h:
        * heap/IsoCellSetInlines.h:
        (JSC::IsoCellSet::forEachMarkedCellInParallel):
        (JSC::IsoCellSet::forEachLiveCell):
        * heap/LargeAllocation.h:
        (JSC::LargeAllocation::subspace const):
        * heap/MarkStackMergingConstraint.cpp:
        (JSC::MarkStackMergingConstraint::executeImpl):
        * heap/MarkStackMergingConstraint.h:
        * heap/MarkedAllocator.cpp:
        (JSC::MarkedAllocator::parallelNotEmptyBlockSource):
        * heap/MarkedBlock.cpp:
        (JSC::MarkedBlock::Handle::didAddToAllocator):
        (JSC::MarkedBlock::Handle::didRemoveFromAllocator):
        * heap/MarkedBlock.h:
        (JSC::MarkedBlock::subspace const):
        * heap/MarkedBlockInlines.h:
        (JSC::MarkedBlock::Handle::forEachLiveCell):
        * heap/MarkedSpaceInlines.h:
        (JSC::MarkedSpace::forEachLiveCell):
        * heap/MarkingConstraint.cpp:
        (JSC::MarkingConstraint::execute):
        (JSC::MarkingConstraint::doParallelWork):
        (JSC::MarkingConstraint::finishParallelWork): Deleted.
        (JSC::MarkingConstraint::doParallelWorkImpl): Deleted.
        (JSC::MarkingConstraint::finishParallelWorkImpl): Deleted.
        * heap/MarkingConstraint.h:
        * heap/MarkingConstraintSet.cpp:
        (JSC::MarkingConstraintSet::add):
        * heap/MarkingConstraintSet.h:
        (JSC::MarkingConstraintSet::add):
        * heap/MarkingConstraintSolver.cpp:
        (JSC::MarkingConstraintSolver::execute):
        (JSC::MarkingConstraintSolver::addParallelTask):
        (JSC::MarkingConstraintSolver::runExecutionThread):
        (JSC::MarkingConstraintSolver::didExecute): Deleted.
        * heap/MarkingConstraintSolver.h:
        (JSC::MarkingConstraintSolver::TaskWithConstraint::TaskWithConstraint):
        (JSC::MarkingConstraintSolver::TaskWithConstraint::operator== const):
        * heap/SimpleMarkingConstraint.cpp:
        (JSC::SimpleMarkingConstraint::SimpleMarkingConstraint):
        (JSC::SimpleMarkingConstraint::executeImpl):
        * heap/SimpleMarkingConstraint.h:
        (JSC::SimpleMarkingConstraint::SimpleMarkingConstraint):
        * heap/SlotVisitor.cpp:
        (JSC::SlotVisitor::addParallelConstraintTask):
        * heap/SlotVisitor.h:
        * heap/Subspace.cpp:
        (JSC::Subspace::sweep):
        * heap/Subspace.h:
        * heap/SubspaceInlines.h:
        (JSC::Subspace::forEachLiveCell):
        * llint/LowLevelInterpreter.asm:
        * runtime/EvalExecutable.cpp:
        (JSC::EvalExecutable::visitChildren):
        * runtime/EvalExecutable.h:
        (JSC::EvalExecutable::codeBlock):
        * runtime/FunctionExecutable.cpp:
        (JSC::FunctionExecutable::baselineCodeBlockFor):
        (JSC::FunctionExecutable::visitChildren):
        * runtime/FunctionExecutable.h:
        * runtime/JSType.h:
        * runtime/ModuleProgramExecutable.cpp:
        (JSC::ModuleProgramExecutable::visitChildren):
        * runtime/ModuleProgramExecutable.h:
        * runtime/ProgramExecutable.cpp:
        (JSC::ProgramExecutable::visitChildren):
        * runtime/ProgramExecutable.h:
        * runtime/ScriptExecutable.cpp:
        (JSC::ScriptExecutable::installCode):
        (JSC::ScriptExecutable::newReplacementCodeBlockFor):
        * runtime/VM.cpp:
        (JSC::VM::VM):
        * runtime/VM.h:
        (JSC::VM::SpaceAndFinalizerSet::SpaceAndFinalizerSet):
        (JSC::VM::SpaceAndFinalizerSet::finalizerSetFor):
        (JSC::VM::forEachCodeBlockSpace):
        * runtime/VMTraps.cpp:
        (JSC::VMTraps::handleTraps):
        * tools/VMInspector.cpp:
        (JSC::VMInspector::codeBlockForMachinePC):
        (JSC::VMInspector::isValidCodeBlock):

2018-01-09  Michael Saboff  <msaboff@apple.com>

        Unreviewed, rolling out r226600 and r226603
        https://bugs.webkit.org/show_bug.cgi?id=181351

        Add a DOM gadget for Spectre testing

        * runtime/Options.h:

2018-01-09  Saam Barati  <sbarati@apple.com>

        Reduce graph size by replacing terminal nodes in blocks that have a ForceOSRExit with Unreachable
        https://bugs.webkit.org/show_bug.cgi?id=181409

        Reviewed by Keith Miller.

        When I was looking at profiler data for Speedometer, I noticed that one of
        the hottest functions in Speedometer is around 1100 bytecode operations long.
        Only about 100 of those bytecode ops ever execute. However, we ended up
        spending a lot of time compiling basic blocks that never executed. We often
        plant ForceOSRExit nodes when we parse bytecodes that have a null value profile.
        This is the case when such a node never executes.
        
        This patch makes it so that anytime a block has a ForceOSRExit, we replace its
        terminal node with an Unreachable node (and remove all nodes after the
        ForceOSRExit). This will cut down on graph size when such a block dominates
        other blocks in the CFG. This allows us to get rid of huge chunks of the CFG
        in certain programs. When doing this transformation, we also insert
        Flushes/PhantomLocals to ensure we can recover values that are bytecode
        live-in to the ForceOSRExit.
        
        Using ForceOSRExit as the signal for this is a bit of a hack. It definitely
        does not get rid of all the CFG that it could. If we decide it's worth
        it, we could use additional inputs into this mechanism. For example, we could
        profile if a basic block ever executes inside the LLInt/Baseline, and
        remove parts of the CFG based on that.
        
        When running Speedometer with the concurrent JIT turned off, this patch
        improves DFG/FTL compile times by around 5%.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::addToGraph):
        (JSC::DFG::ByteCodeParser::parse):

2018-01-09  Mark Lam  <mark.lam@apple.com>

        ASSERTION FAILED: pair.second->m_type & PropertyNode::Getter
        https://bugs.webkit.org/show_bug.cgi?id=181388
        <rdar://problem/36349351>

        Reviewed by Saam Barati.

        When there are duplicate setters or getters, we may end up overwriting a getter
        with a setter, or vice versa.  This patch adds tracking for getters/setters that
        have been overwritten with duplicates and ignore them.

        * bytecompiler/NodesCodegen.cpp:
        (JSC::PropertyListNode::emitBytecode):
        * parser/NodeConstructors.h:
        (JSC::PropertyNode::PropertyNode):
        * parser/Nodes.h:
        (JSC::PropertyNode::isOverriddenByDuplicate const):
        (JSC::PropertyNode::setIsOverriddenByDuplicate):

2018-01-08  Zan Dobersek  <zdobersek@igalia.com>

        REGRESSION(r225913): about 30 JSC test failures on ARMv7
        https://bugs.webkit.org/show_bug.cgi?id=181162
        <rdar://problem/36261349>

        Unreviewed follow-up to r226298. Enable the fast case in
        DFG::SpeculativeJIT::compileArraySlice() for any 64-bit platform,
        assuming in good faith that enough GP registers are available on any
        such configuration. The accompanying comment is adjusted to describe
        this assumption.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileArraySlice):

2018-01-08  JF Bastien  <jfbastien@apple.com>

        WebAssembly: mask indexed accesses to Table
        https://bugs.webkit.org/show_bug.cgi?id=181412
        <rdar://problem/36363236>

        Reviewed by Saam Barati.

        WebAssembly Table indexed accesses are user-controlled and
        bounds-checked. Force allocations of Table data to be a
        power-of-two, and explicitly mask accesses after bounds-check
        branches.

        Rename misleading usage of "size" when "length" of a Table was
        intended.

        Rename the Spectre option from "disable" to "enable".

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::SpeculativeJIT):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::LowerDFGToB3):
        * jit/JIT.cpp:
        (JSC::JIT::JIT):
        * runtime/Options.h:
        * wasm/WasmB3IRGenerator.cpp:
        (JSC::Wasm::B3IRGenerator::emitCheckAndPreparePointer):
        (JSC::Wasm::B3IRGenerator::addCallIndirect):
        * wasm/WasmTable.cpp:
        (JSC::Wasm::Table::allocatedLength):
        (JSC::Wasm::Table::setLength):
        (JSC::Wasm::Table::create):
        (JSC::Wasm::Table::Table):
        (JSC::Wasm::Table::grow):
        (JSC::Wasm::Table::clearFunction):
        (JSC::Wasm::Table::setFunction):
        * wasm/WasmTable.h:
        (JSC::Wasm::Table::length const):
        (JSC::Wasm::Table::offsetOfLength):
        (JSC::Wasm::Table::offsetOfMask):
        (JSC::Wasm::Table::mask const):
        (JSC::Wasm::Table::isValidLength):
        * wasm/js/JSWebAssemblyInstance.cpp:
        (JSC::JSWebAssemblyInstance::create):
        * wasm/js/JSWebAssemblyTable.cpp:
        (JSC::JSWebAssemblyTable::JSWebAssemblyTable):
        (JSC::JSWebAssemblyTable::visitChildren):
        (JSC::JSWebAssemblyTable::grow):
        (JSC::JSWebAssemblyTable::getFunction):
        (JSC::JSWebAssemblyTable::clearFunction):
        (JSC::JSWebAssemblyTable::setFunction):
        * wasm/js/JSWebAssemblyTable.h:
        (JSC::JSWebAssemblyTable::isValidLength):
        (JSC::JSWebAssemblyTable::length const):
        (JSC::JSWebAssemblyTable::allocatedLength const):
        * wasm/js/WebAssemblyModuleRecord.cpp:
        (JSC::WebAssemblyModuleRecord::evaluate):
        * wasm/js/WebAssemblyTablePrototype.cpp:
        (JSC::webAssemblyTableProtoFuncLength):
        (JSC::webAssemblyTableProtoFuncGrow):
        (JSC::webAssemblyTableProtoFuncGet):
        (JSC::webAssemblyTableProtoFuncSet):

2018-01-08  Michael Saboff  <msaboff@apple.com>

        Add a DOM gadget for Spectre testing
        https://bugs.webkit.org/show_bug.cgi?id=181351

        Reviewed by Michael Saboff.

        Added a new JSC::Option named enableSpectreGadgets to enable any gadgets added to test
        Spectre mitigations.

        * runtime/Options.h:

2018-01-08  Mark Lam  <mark.lam@apple.com>

        Rename CodeBlock::m_vm to CodeBlock::m_poisonedVM.
        https://bugs.webkit.org/show_bug.cgi?id=181403
        <rdar://problem/36359789>

        Rubber-stamped by JF Bastien.

        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::CodeBlock):
        (JSC::CodeBlock::~CodeBlock):
        (JSC::CodeBlock::setConstantRegisters):
        (JSC::CodeBlock::propagateTransitions):
        (JSC::CodeBlock::finalizeLLIntInlineCaches):
        (JSC::CodeBlock::jettison):
        (JSC::CodeBlock::predictedMachineCodeSize):
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::vm const):
        (JSC::CodeBlock::addConstant):
        (JSC::CodeBlock::heap const):
        (JSC::CodeBlock::replaceConstant):
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter32_64.asm:
        * llint/LowLevelInterpreter64.asm:

2018-01-07  Mark Lam  <mark.lam@apple.com>

        Apply poisoning to more pointers in JSC.
        https://bugs.webkit.org/show_bug.cgi?id=181096
        <rdar://problem/36182970>

        Reviewed by JF Bastien.

        * assembler/MacroAssembler.h:
        (JSC::MacroAssembler::xorPtr):
        * assembler/MacroAssemblerARM64.h:
        (JSC::MacroAssemblerARM64::xor64):
        * assembler/MacroAssemblerX86_64.h:
        (JSC::MacroAssemblerX86_64::xor64):
        - Add xorPtr implementation.

        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::inferredName const):
        (JSC::CodeBlock::CodeBlock):
        (JSC::CodeBlock::finishCreation):
        (JSC::CodeBlock::~CodeBlock):
        (JSC::CodeBlock::setConstantRegisters):
        (JSC::CodeBlock::visitWeakly):
        (JSC::CodeBlock::visitChildren):
        (JSC::CodeBlock::propagateTransitions):
        (JSC::CodeBlock::WeakReferenceHarvester::visitWeakReferences):
        (JSC::CodeBlock::finalizeLLIntInlineCaches):
        (JSC::CodeBlock::finalizeBaselineJITInlineCaches):
        (JSC::CodeBlock::UnconditionalFinalizer::finalizeUnconditionally):
        (JSC::CodeBlock::jettison):
        (JSC::CodeBlock::predictedMachineCodeSize):
        (JSC::CodeBlock::findPC):
        * bytecode/CodeBlock.h:
        (JSC::CodeBlock::UnconditionalFinalizer::UnconditionalFinalizer):
        (JSC::CodeBlock::WeakReferenceHarvester::WeakReferenceHarvester):
        (JSC::CodeBlock::stubInfoBegin):
        (JSC::CodeBlock::stubInfoEnd):
        (JSC::CodeBlock::callLinkInfosBegin):
        (JSC::CodeBlock::callLinkInfosEnd):
        (JSC::CodeBlock::instructions):
        (JSC::CodeBlock::instructions const):
        (JSC::CodeBlock::vm const):
        * dfg/DFGOSRExitCompilerCommon.h:
        (JSC::DFG::adjustFrameAndStackInOSRExitCompilerThunk):
        * jit/JIT.h:
        * llint/LLIntOfflineAsmConfig.h:
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter64.asm:
        * parser/UnlinkedSourceCode.h:
        * runtime/JSCPoison.h:
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        * runtime/JSGlobalObject.h:
        * runtime/JSScriptFetchParameters.h:
        * runtime/JSScriptFetcher.h:
        * runtime/StructureTransitionTable.h:
        * wasm/js/JSWebAssemblyCodeBlock.cpp:
        (JSC::JSWebAssemblyCodeBlock::JSWebAssemblyCodeBlock):
        (JSC::JSWebAssemblyCodeBlock::visitChildren):
        (JSC::JSWebAssemblyCodeBlock::UnconditionalFinalizer::finalizeUnconditionally):
        * wasm/js/JSWebAssemblyCodeBlock.h:

2018-01-06  Yusuke Suzuki  <utatane.tea@gmail.com>

        Object.getOwnPropertyNames includes "arguments" and "caller" for bound functions
        https://bugs.webkit.org/show_bug.cgi?id=181321

        Reviewed by Saam Barati.

        According to ECMA262 16.2[1], functions created using the bind method must not have
        "caller" and "arguments" own properties.

        [1]: https://tc39.github.io/ecma262/#sec-forbidden-extensions

        * runtime/JSBoundFunction.cpp:
        (JSC::JSBoundFunction::finishCreation):

2018-01-05  JF Bastien  <jfbastien@apple.com>

        WebAssembly: poison JS object's secrets
        https://bugs.webkit.org/show_bug.cgi?id=181339
        <rdar://problem/36325001>

        Reviewed by Mark Lam.

        Separating WebAssembly's JS objects from their non-JS
        implementation means that all interesting information lives
        outside of the JS object itself. This patch poisons each JS
        object's pointer to non-JS implementation using the poisoning
        mechanism and a unique key per JS object type origin.

        * runtime/JSCPoison.h:
        * wasm/js/JSToWasm.cpp:
        (JSC::Wasm::createJSToWasmWrapper): JS -> wasm stores the JS
        object in a stack slot when fast TLS is disabled. This requires
        that we unpoison the Wasm::Instance.
        * wasm/js/JSWebAssemblyCodeBlock.h:
        * wasm/js/JSWebAssemblyInstance.h:
        (JSC::JSWebAssemblyInstance::offsetOfPoisonedInstance): renamed to
        be explicit that the pointer is poisoned.
        * wasm/js/JSWebAssemblyMemory.h:
        * wasm/js/JSWebAssemblyModule.h:
        * wasm/js/JSWebAssemblyTable.h:

2018-01-05  Michael Saboff  <msaboff@apple.com>

        Add ability to disable indexed property masking for testing
        https://bugs.webkit.org/show_bug.cgi?id=181350

        Reviewed by Keith Miller.

        Made the masking of indexed properties runtime controllable via a new JSC::Option
        named disableSpectreMitigations.  This is done to test the efficacy of that mitigation.

        The new option has a generic name as it will probably be used to disable future mitigations.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::SpeculativeJIT):
        (JSC::DFG::SpeculativeJIT::loadFromIntTypedArray):
        (JSC::DFG::SpeculativeJIT::compileGetByValOnFloatTypedArray):
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::LowerDFGToB3):
        (JSC::FTL::DFG::LowerDFGToB3::maskedIndex):
        (JSC::FTL::DFG::LowerDFGToB3::pointerIntoTypedArray):
        * jit/JIT.cpp:
        (JSC::JIT::JIT):
        * jit/JIT.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emitDoubleLoad):
        (JSC::JIT::emitContiguousLoad):
        (JSC::JIT::emitArrayStorageLoad):
        * runtime/Options.h:
        * wasm/WasmB3IRGenerator.cpp:
        (JSC::Wasm::B3IRGenerator::emitCheckAndPreparePointer):

2018-01-05  Michael Saboff  <msaboff@apple.com>

        Allow JSC Config Files to set Restricted Options
        https://bugs.webkit.org/show_bug.cgi?id=181352

        Reviewed by Mark Lam.

        * runtime/ConfigFile.cpp:
        (JSC::ConfigFile::parse):

2018-01-04  Keith Miller  <keith_miller@apple.com>

        TypedArrays and Wasm should use index masking.
        https://bugs.webkit.org/show_bug.cgi?id=181313

        Reviewed by Michael Saboff.

        We should have index masking for our TypedArray code in the
        DFG/FTL and for Wasm when doing bounds checking. Index masking for
        Wasm is added to the WasmBoundsCheckValue. Since we don't CSE any
        WasmBoundsCheckValues we don't need to worry about combining a
        bounds check for a load and a store. I went with fusing the
        pointer masking in the WasmBoundsCheckValue since it should reduce
        additional compiler overhead.

        * b3/B3LowerToAir.cpp:
        * b3/B3Validate.cpp:
        * b3/B3WasmBoundsCheckValue.cpp:
        (JSC::B3::WasmBoundsCheckValue::WasmBoundsCheckValue):
        (JSC::B3::WasmBoundsCheckValue::dumpMeta const):
        * b3/B3WasmBoundsCheckValue.h:
        (JSC::B3::WasmBoundsCheckValue::pinnedIndexingMask const):
        * b3/air/AirCustom.h:
        (JSC::B3::Air::WasmBoundsCheckCustom::generate):
        * b3/testb3.cpp:
        (JSC::B3::testWasmBoundsCheck):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::emitAllocateRawObject):
        (JSC::DFG::SpeculativeJIT::loadFromIntTypedArray):
        (JSC::DFG::SpeculativeJIT::compileGetByValOnIntTypedArray):
        (JSC::DFG::SpeculativeJIT::compileGetByValOnFloatTypedArray):
        (JSC::DFG::SpeculativeJIT::compileNewTypedArrayWithSize):
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileAtomicsReadModifyWrite):
        (JSC::FTL::DFG::LowerDFGToB3::compileGetByVal):
        (JSC::FTL::DFG::LowerDFGToB3::compileNewTypedArray):
        (JSC::FTL::DFG::LowerDFGToB3::pointerIntoTypedArray):
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emitIntTypedArrayGetByVal):
        * runtime/Butterfly.h:
        (JSC::Butterfly::computeIndexingMask const):
        (JSC::Butterfly::computeIndexingMaskForVectorLength): Deleted.
        * runtime/JSArrayBufferView.cpp:
        (JSC::JSArrayBufferView::JSArrayBufferView):
        * wasm/WasmB3IRGenerator.cpp:
        (JSC::Wasm::B3IRGenerator::B3IRGenerator):
        (JSC::Wasm::B3IRGenerator::restoreWebAssemblyGlobalState):
        (JSC::Wasm::B3IRGenerator::emitCheckAndPreparePointer):
        (JSC::Wasm::B3IRGenerator::load):
        (JSC::Wasm::B3IRGenerator::store):
        (JSC::Wasm::B3IRGenerator::addCallIndirect):
        * wasm/WasmBinding.cpp:
        (JSC::Wasm::wasmToWasm):
        * wasm/WasmMemory.cpp:
        (JSC::Wasm::Memory::Memory):
        (JSC::Wasm::Memory::grow):
        * wasm/WasmMemory.h:
        (JSC::Wasm::Memory::offsetOfIndexingMask):
        * wasm/WasmMemoryInformation.cpp:
        (JSC::Wasm::PinnedRegisterInfo::get):
        (JSC::Wasm::PinnedRegisterInfo::PinnedRegisterInfo):
        * wasm/WasmMemoryInformation.h:
        (JSC::Wasm::PinnedRegisterInfo::toSave const):
        * wasm/js/JSToWasm.cpp:
        (JSC::Wasm::createJSToWasmWrapper):

2018-01-05  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r226434.
        https://bugs.webkit.org/show_bug.cgi?id=181322

        32bit JSC failure in x86 (Requested by yusukesuzuki on
        #webkit).

        Reverted changeset:

        "[DFG] Unify ToNumber implementation in 32bit and 64bit by
        changing 32bit Int32Tag and LowestTag"
        https://bugs.webkit.org/show_bug.cgi?id=181134
        https://trac.webkit.org/changeset/226434

2018-01-04  Devin Rousso  <webkit@devinrousso.com>

        Web Inspector: replace HTMLCanvasElement with CanvasRenderingContext for instrumentation logic
        https://bugs.webkit.org/show_bug.cgi?id=180770

        Reviewed by Joseph Pecoraro.

        * inspector/protocol/Canvas.json:

2018-01-04  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r226405.
        https://bugs.webkit.org/show_bug.cgi?id=181318

        Speculative rollout due to Octane/SplayLatency,Octane/Splay
        regressions (Requested by yusukesuzuki on #webkit).

        Reverted changeset:

        "[JSC] Create parallel SlotVisitors apriori"
        https://bugs.webkit.org/show_bug.cgi?id=180907
        https://trac.webkit.org/changeset/226405

2018-01-04  Saam Barati  <sbarati@apple.com>

        Do value profiling in to_this
        https://bugs.webkit.org/show_bug.cgi?id=181299

        Reviewed by Filip Pizlo.

        This patch adds value profiling to to_this. We use the result of the value
        profiling only for strict mode code when we don't predict that the input is
        of a specific type. This helps when the input is SpecCellOther. Such cells
        might implement a custom ToThis, which can produce an arbitrary result. Before
        this patch, in prediction propagation, we were saying that a ToThis with a
        SpecCellOther input also produced SpecCellOther. However, this is incorrect,
        given that the input may implement ToThis that produces an arbitrary result.
        This is seen inside Speedometer. This patch fixes an OSR exit loop in Speedometer.
        
        Interestingly, this patch only does value profiling on the slow path. The fast
        path of to_this in the LLInt/baseline just perform a structure check. If it
        passes, the result is the same as the input. Therefore, doing value profiling
        from the fast path wouldn't actually produce new information for the ValueProfile.

        * bytecode/BytecodeDumper.cpp:
        (JSC::BytecodeDumper<Block>::dumpBytecode):
        * bytecode/BytecodeList.json:
        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::finishCreation):
        * bytecompiler/BytecodeGenerator.cpp:
        (JSC::BytecodeGenerator::BytecodeGenerator):
        (JSC::BytecodeGenerator::emitToThis):
        * bytecompiler/BytecodeGenerator.h:
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::parseBlock):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::hasHeapPrediction):
        * dfg/DFGPredictionPropagationPhase.cpp:
        * runtime/CommonSlowPaths.cpp:
        (JSC::SLOW_PATH_DECL):

2018-01-04  Yusuke Suzuki  <utatane.tea@gmail.com>

        [DFG] Unify ToNumber implementation in 32bit and 64bit by changing 32bit Int32Tag and LowestTag
        https://bugs.webkit.org/show_bug.cgi?id=181134

        Reviewed by Mark Lam.

        We would like to unify DFG ToNumber implementation in 32bit and 64bit. One problem is that
        branchIfNumber signature is different between 32bit and 64bit. 32bit implementation requires
        an additional scratch register. We do not want to allocate an unnecessary register in 64bit
        implementation.

        This patch removes the additional register in branchIfNumber/branchIfNotNumber in both 32bit
        and 64bit implementation. To achieve this goal, we change Int32Tag and LowestTag order. By
        setting Int32Tag as LowestTag, we can query whether the given tag is a number by checking
        `<= LowestTag(Int32Tag)`.

        We also change the order of UndefinedTag, NullTag, and BooleanTag to keep `(UndefinedTag | 1) == NullTag`.

        We also clean up speculateMisc implementation by adding branchIfMisc/branchIfNotMisc.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileValueToInt32):
        (JSC::DFG::SpeculativeJIT::compileDoubleRep):
        (JSC::DFG::SpeculativeJIT::speculateNumber):
        (JSC::DFG::SpeculativeJIT::speculateMisc):
        (JSC::DFG::SpeculativeJIT::compileNormalizeMapKey):
        (JSC::DFG::SpeculativeJIT::compileToNumber):
        * dfg/DFGSpeculativeJIT.h:
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined):
        (JSC::DFG::SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined):
        (JSC::DFG::SpeculativeJIT::compileObjectOrOtherLogicalNot):
        (JSC::DFG::SpeculativeJIT::emitObjectOrOtherBranch):
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * jit/AssemblyHelpers.cpp:
        (JSC::AssemblyHelpers::branchIfNotType):
        (JSC::AssemblyHelpers::jitAssertIsJSNumber):
        (JSC::AssemblyHelpers::emitConvertValueToBoolean):
        * jit/AssemblyHelpers.h:
        (JSC::AssemblyHelpers::branchIfMisc):
        (JSC::AssemblyHelpers::branchIfNotMisc):
        (JSC::AssemblyHelpers::branchIfNumber):
        (JSC::AssemblyHelpers::branchIfNotNumber):
        (JSC::AssemblyHelpers::branchIfNotDoubleKnownNotInt32):
        (JSC::AssemblyHelpers::emitTypeOf):
        * jit/JITAddGenerator.cpp:
        (JSC::JITAddGenerator::generateFastPath):
        * jit/JITArithmetic32_64.cpp:
        (JSC::JIT::emitBinaryDoubleOp):
        * jit/JITDivGenerator.cpp:
        (JSC::JITDivGenerator::loadOperand):
        * jit/JITMulGenerator.cpp:
        (JSC::JITMulGenerator::generateInline):
        (JSC::JITMulGenerator::generateFastPath):
        * jit/JITNegGenerator.cpp:
        (JSC::JITNegGenerator::generateInline):
        (JSC::JITNegGenerator::generateFastPath):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emit_op_is_number):
        (JSC::JIT::emit_op_jeq_null):
        (JSC::JIT::emit_op_jneq_null):
        (JSC::JIT::emit_op_to_number):
        (JSC::JIT::emit_op_profile_type):
        * jit/JITRightShiftGenerator.cpp:
        (JSC::JITRightShiftGenerator::generateFastPath):
        * jit/JITSubGenerator.cpp:
        (JSC::JITSubGenerator::generateInline):
        (JSC::JITSubGenerator::generateFastPath):
        * llint/LLIntData.cpp:
        (JSC::LLInt::Data::performAssertions):
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter32_64.asm:
        * runtime/JSCJSValue.h:

2018-01-04  JF Bastien  <jfbastien@apple.com>

        Add assembler support for x86 lfence and sfence
        https://bugs.webkit.org/show_bug.cgi?id=181311
        <rdar://problem/36301780>

        Reviewed by Michael Saboff.

        Useful for testing performance of serializing instructions (hint:
        it's not good).

        * assembler/MacroAssemblerX86Common.h:
        (JSC::MacroAssemblerX86Common::lfence):
        (JSC::MacroAssemblerX86Common::sfence):
        * assembler/X86Assembler.h:
        (JSC::X86Assembler::lfence):
        (JSC::X86Assembler::sfence):

2018-01-04  Saam Barati  <sbarati@apple.com>

        Add a new pattern matching rule to Graph::methodOfGettingAValueProfileFor for SetLocal(@nodeWithHeapPrediction)
        https://bugs.webkit.org/show_bug.cgi?id=181296

        Reviewed by Filip Pizlo.

        Inside Speedometer's Ember test, there is a recompile loop like:
        a: GetByVal(..., semanticOriginX)
        b: SetLocal(Cell:@a, semanticOriginX)
        
        where the cell check always fails. For reasons I didn't investigate, the
        baseline JIT's value profiling doesn't accurately capture the GetByVal's
        result.
        
        However, when compiling this cell speculation check in the DFG, we get a null
        MethodOfGettingAValueProfile inside Graph::methodOfGettingAValueProfileFor for
        this IR pattern because both @a and @b have the same semantic origin. We
        should not follow the same semantic origin heuristic when dealing with
        SetLocal since SetLocal(@nodeWithHeapPrediction) is such a common IR pattern.
        For patterns like this, we introduce a new heuristic: @NodeThatDoesNotProduceAValue(@nodeWithHeapPrediction).
        For this IR pattern, we will update the value profile for the semantic origin
        for @nodeWithHeapPrediction. So, for the Speedometer example above, we
        will correctly update the GetByVal's value profile, which will prevent
        an OSR exit loop.

        * dfg/DFGGraph.cpp:
        (JSC::DFG::Graph::methodOfGettingAValueProfileFor):

2018-01-04  Keith Miller  <keith_miller@apple.com>

        Array Storage operations sometimes did not update the indexing mask correctly.
        https://bugs.webkit.org/show_bug.cgi?id=181301

        Reviewed by Mark Lam.

        I will add tests in a follow up patch. See: https://bugs.webkit.org/show_bug.cgi?id=181303

        * runtime/JSArray.cpp:
        (JSC::JSArray::shiftCountWithArrayStorage):
        * runtime/JSObject.cpp:
        (JSC::JSObject::increaseVectorLength):

2018-01-04  Yusuke Suzuki  <utatane.tea@gmail.com>

        [DFG] Define defs for MapSet/SetAdd to participate in CSE
        https://bugs.webkit.org/show_bug.cgi?id=179911

        Reviewed by Saam Barati.

        With this patch, our MapSet and SetAdd DFG nodes participate in CSE.
        To handle a bit tricky DFG Map operation nodes, MapSet and SetAdd
        produce added bucket as its result. Subsequent GetMapBucket will
        be removed by CSE.

        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGNodeType.h:
        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileSetAdd):
        (JSC::DFG::SpeculativeJIT::compileMapSet):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation):
        * ftl/FTLLowerDFGToB3.cpp:
        (JSC::FTL::DFG::LowerDFGToB3::compileSetAdd):
        (JSC::FTL::DFG::LowerDFGToB3::compileMapSet):
        * jit/JITOperations.h:
        * runtime/HashMapImpl.h:
        (JSC::HashMapImpl::addNormalized):
        (JSC::HashMapImpl::addNormalizedInternal):

2018-01-04  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Remove LocalScope
        https://bugs.webkit.org/show_bug.cgi?id=181206

        Reviewed by Geoffrey Garen.

        The last user of HandleStack and LocalScope is JSON. But MarkedArgumentBuffer is enough for their use.
        This patch changes JSON parsing and stringifying to using MarkedArgumentBuffer. And remove HandleStack
        and LocalScope.

        We make Stringifier and Walker WTF_FORBID_HEAP_ALLOCATION to place them on the stack. So they can hold
        JSObject* directly in their fields.

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * heap/HandleStack.cpp: Removed.
        * heap/HandleStack.h: Removed.
        * heap/Heap.cpp:
        (JSC::Heap::addCoreConstraints):
        * heap/Heap.h:
        (JSC::Heap::handleSet):
        (JSC::Heap::handleStack): Deleted.
        * heap/Local.h: Removed.
        * heap/LocalScope.h: Removed.
        * runtime/JSONObject.cpp:
        (JSC::Stringifier::Holder::object const):
        (JSC::gap):
        (JSC::Stringifier::Stringifier):
        (JSC::Stringifier::stringify):
        (JSC::Stringifier::appendStringifiedValue):
        (JSC::Stringifier::Holder::Holder):
        (JSC::Stringifier::Holder::appendNextProperty):
        (JSC::Walker::Walker):
        (JSC::Walker::callReviver):
        (JSC::Walker::walk):
        (JSC::JSONProtoFuncParse):
        (JSC::JSONProtoFuncStringify):
        (JSC::JSONParse):
        (JSC::JSONStringify):

2018-01-04  Yusuke Suzuki  <utatane.tea@gmail.com>

        [FTL] Optimize ObjectAllocationSinking mergePointerSets by using removeIf
        https://bugs.webkit.org/show_bug.cgi?id=180238

        Reviewed by Saam Barati.

        We can optimize ObjectAllocationSinking a bit by using removeIf.

        * dfg/DFGObjectAllocationSinkingPhase.cpp:

2018-01-04  Yusuke Suzuki  <utatane.tea@gmail.com>

        [JSC] Create parallel SlotVisitors apriori
        https://bugs.webkit.org/show_bug.cgi?id=180907

        Reviewed by Saam Barati.

        The number of SlotVisitors are capped with the number of HeapHelperPool's threads + 2.
        If we create these SlotVisitors apriori, we do not need to create SlotVisitors dynamically.
        Then we do not need to grab locks while iterating all the SlotVisitors.

        In addition, we do not need to consider the case that the number of SlotVisitors increases
        after setting up VisitCounters in MarkingConstraintSolver since the number of SlotVisitors
        does not increase any more.

        * heap/Heap.cpp:
        (JSC::Heap::Heap):
        (JSC::Heap::runBeginPhase):
        * heap/Heap.h:
        * heap/HeapInlines.h:
        (JSC::Heap::forEachSlotVisitor):
        (JSC::Heap::numberOfSlotVisitors): Deleted.
        * heap/MarkingConstraintSolver.cpp:
        (JSC::MarkingConstraintSolver::didVisitSomething const):

2018-01-03  Ting-Wei Lan  <lantw44@gmail.com>

        Replace hard-coded paths in shebangs with #!/usr/bin/env
        https://bugs.webkit.org/show_bug.cgi?id=181040

        Reviewed by Alex Christensen.

        * Scripts/UpdateContents.py:
        * Scripts/cssmin.py:
        * Scripts/generate-combined-inspector-json.py:
        * Scripts/xxd.pl:
        * create_hash_table:
        * generate-bytecode-files:
        * wasm/generateWasm.py:
        * wasm/generateWasmOpsHeader.py:
        * yarr/generateYarrCanonicalizeUnicode:

2018-01-03  Michael Saboff  <msaboff@apple.com>

        Disable SharedArrayBuffers from Web API
        https://bugs.webkit.org/show_bug.cgi?id=181266

        Reviewed by Saam Barati.

        Removed SharedArrayBuffer prototype and structure from GlobalObject creation
        to disable.

        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        (JSC::JSGlobalObject::visitChildren):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::arrayBufferPrototype const):
        (JSC::JSGlobalObject::arrayBufferStructure const):

2018-01-03  Michael Saboff  <msaboff@apple.com>

        Add "noInline" to $vm
        https://bugs.webkit.org/show_bug.cgi?id=181265

        Reviewed by Mark Lam.

        This would be useful for web based tests.

        * tools/JSDollarVM.cpp:
        (JSC::getExecutableForFunction):
        (JSC::functionNoInline):
        (JSC::JSDollarVM::finishCreation):

2018-01-03  Michael Saboff  <msaboff@apple.com>

        Remove unnecessary flushing of Butterfly pointer in functionCpuClflush()
        https://bugs.webkit.org/show_bug.cgi?id=181263

        Reviewed by Mark Lam.

        Flushing the butterfly pointer provides no benefit and slows this function.

        * tools/JSDollarVM.cpp:
        (JSC::functionCpuClflush):

2018-01-03  Saam Barati  <sbarati@apple.com>

        Fix BytecodeParser op_catch assert to work with useProfiler=1
        https://bugs.webkit.org/show_bug.cgi?id=181260

        Reviewed by Keith Miller.

        op_catch was asserting that the current block was empty. This is only true
        if the profiler isn't enabled. When the profiler is enabled, we will
        insert a CountExecution node before each bytecode. This patch fixes the
        assert to work with the profiler.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::parseBlock):

2018-01-03  Per Arne Vollan  <pvollan@apple.com>

        [Win][Debug] testapi link error.
        https://bugs.webkit.org/show_bug.cgi?id=181247
        <rdar://problem/36166729>

        Reviewed by Brent Fulgham.

        Do not set the runtime library compile flag for C files, it is already set to the correct value.
 
        * shell/PlatformWin.cmake:

2018-01-03  Robin Morisset  <rmorisset@apple.com>

        Inlining of a function that ends in op_unreachable crashes
        https://bugs.webkit.org/show_bug.cgi?id=181027

        Reviewed by Filip Pizlo.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::allocateTargetableBlock):
        (JSC::DFG::ByteCodeParser::inlineCall):

2018-01-02  Saam Barati  <sbarati@apple.com>

        Incorrect assertion inside AccessCase
        https://bugs.webkit.org/show_bug.cgi?id=181200
        <rdar://problem/35494754>

        Reviewed by Yusuke Suzuki.

        Consider a PutById compiled to a setter in a function like so:
        
        ```
        function foo(o) { o.f = o; }
        ```
        
        The DFG will often assign the same registers to the baseGPR (o in o.f) and the
        valueRegsPayloadGPR (o in the RHS). The code totally works when these are assigned
        to the same register. However, we're asserting that they're not the same register.
        This patch just removes this invalid assertion.

        * bytecode/AccessCase.cpp:
        (JSC::AccessCase::generateImpl):

2018-01-02  Caio Lima  <ticaiolima@gmail.com>

        [ESNext][BigInt] Implement BigIntConstructor and BigIntPrototype
        https://bugs.webkit.org/show_bug.cgi?id=175359

        Reviewed by Yusuke Suzuki.

        This patch is implementing BigIntConstructor and BigIntPrototype
        following spec[1, 2]. As addition, we are also implementing BigIntObject
        warapper to handle ToObject(v) abstract operation when "v" is a BigInt
        primitive. With these classes, now it's possible to syntetize
        BigInt.prototype and then call "toString", "valueOf" and
        "toLocaleString" when the primitive is a BigInt.
        BigIntConstructor exposes an API to parse other primitives such as
        Number, Boolean and String to BigInt.
        We decided to skip parseInt implementation, since it was removed from
        spec.

        [1] - https://tc39.github.io/proposal-bigint/#sec-bigint-constructor
        [2] - https://tc39.github.io/proposal-bigint/#sec-properties-of-the-bigint-prototype-object 

        * CMakeLists.txt:
        * DerivedSources.make:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * Sources.txt:
        * jsc.cpp:
        * runtime/BigIntConstructor.cpp: Added.
        (JSC::BigIntConstructor::BigIntConstructor):
        (JSC::BigIntConstructor::finishCreation):
        (JSC::isSafeInteger):
        (JSC::toBigInt):
        (JSC::callBigIntConstructor):
        (JSC::bigIntConstructorFuncAsUintN):
        (JSC::bigIntConstructorFuncAsIntN):
        * runtime/BigIntConstructor.h: Added.
        (JSC::BigIntConstructor::create):
        (JSC::BigIntConstructor::createStructure):
        * runtime/BigIntObject.cpp: Added.
        (JSC::BigIntObject::BigIntObject):
        (JSC::BigIntObject::finishCreation):
        (JSC::BigIntObject::toStringName):
        (JSC::BigIntObject::defaultValue):
        * runtime/BigIntObject.h: Added.
        (JSC::BigIntObject::create):
        (JSC::BigIntObject::internalValue const):
        (JSC::BigIntObject::createStructure):
        * runtime/BigIntPrototype.cpp: Added.
        (JSC::BigIntPrototype::BigIntPrototype):
        (JSC::BigIntPrototype::finishCreation):
        (JSC::toThisBigIntValue):
        (JSC::bigIntProtoFuncToString):
        (JSC::bigIntProtoFuncToLocaleString):
        (JSC::bigIntProtoFuncValueOf):
        * runtime/BigIntPrototype.h: Added.
        (JSC::BigIntPrototype::create):
        (JSC::BigIntPrototype::createStructure):
        * runtime/IntlCollator.cpp:
        (JSC::IntlCollator::initializeCollator):
        * runtime/IntlNumberFormat.cpp:
        (JSC::IntlNumberFormat::initializeNumberFormat):
        * runtime/JSBigInt.cpp:
        (JSC::JSBigInt::createFrom):
        (JSC::JSBigInt::parseInt):
        (JSC::JSBigInt::toObject const):
        * runtime/JSBigInt.h:
        * runtime/JSCJSValue.cpp:
        (JSC::JSValue::synthesizePrototype const):
        * runtime/JSCPoisonedPtr.cpp:
        * runtime/JSCell.cpp:
        (JSC::JSCell::toObjectSlow const):
        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::init):
        (JSC::JSGlobalObject::visitChildren):
        * runtime/JSGlobalObject.h:
        (JSC::JSGlobalObject::bigIntPrototype const):
        (JSC::JSGlobalObject::bigIntObjectStructure const):
        * runtime/StructureCache.h:
        * runtime/StructureInlines.h:
        (JSC::prototypeForLookupPrimitiveImpl):

2018-01-02  Tim Horton  <timothy_horton@apple.com>

        Fix the MathCommon build with a recent compiler
        https://bugs.webkit.org/show_bug.cgi?id=181216

        Reviewed by Sam Weinig.

        * runtime/MathCommon.cpp:
        (JSC::fdlibmPow):
        This cast drops the 'const' qualifier from the pointer to 'one',
        but it doesn't have to, and it makes the compiler sad.

== Rolled over to ChangeLog-2018-01-01 ==
